[[appendix-b-cql-reference]]
= Appendix B – CQL Reference
:page-layout: current
:sectnums:
:sectanchors:
:toc:

This appendix provides a reference for all the system-defined types, operators, and functions that can be used within CQL. It is intended to provide complete semantics for each available type and operator as a companion to the Author’s and Developer’s Guides. The reference is organized by operator category.

For each type, the definition and semantics are provided. Note that because CQL does not define a type declaration syntax, the definitions are expressed in a pseudo-syntax.

For each operator or function, the signature, semantics, and usually an example are provided. Note that for built-in operators, the signature is expressed in a pseudo-syntax intended to clearly define the operator and its parameters. Although the symbolic operators may in general be prefix, infix, or postfix operators, the signatures for each operator are defined using function definition syntax for consistency and ease of representation. For example, the signature for the [.kw]#and# operator is given as:

[source,cql]
----
and(left Boolean, right Boolean) Boolean
----

Even though [.kw]#and# is an infix operator and would be invoked as in the following expression:

[source,cql]
----
InDemographic and NeedsScreening
----

[[types-2]]
== Types

[[any]]
=== Any

*Definition:*

[source,cql]
----
simple type Any
----

*Description:*

The [.id]#Any# type is the maximal supertype in the CQL type system, meaning that all types derive from [.id]#Any#, including list, interval, and structured types. In addition, the type of a [.kw]#null# result is [.id]#Any#.

[[boolean-1]]
=== Boolean

*Definition:*

[source,cql]
----
simple type Boolean
----

*Description:*

The [.id]#Boolean# type represents the logical boolean values [.kw]#true# and [.kw]#false#. The result of logical operations within CQL use the [.id]#Boolean# type, and constructs within the language that expect a conditional result, such as a where clause or conditional expression, expect results of the [.id]#Boolean# type.

[[code-1]]
=== Code

*Definition:*

[source,cql]
----
structured type Code
{
  code String,
  display String,
  system String,
  version String
}
----

*Description:*

The [.id]#Code# type represents single terminology codes within CQL.

[[concept-1]]
=== Concept

*Definition:*

[source,cql]
----
structured type Concept
{
  codes List<Code>,
  display String
}
----

*Description:*

The [.id]#Concept# type represents a single terminological concept within CQL.

[[date]]
=== Date

*Definition:*

[source,cql]
----
simple type Date
----

*Description:*

The [.id]#Date# type represents date values with potential uncertainty within CQL.

CQL supports date values in the range @0001-01-01 to @9999-12-31 with a 1 day step size.

[[datetime]]
=== DateTime

*Definition:*

[source,cql]
----
simple type DateTime
----

*Description:*

The [.id]#DateTime# type represents date and time values with potential uncertainty within CQL.

CQL supports date and time values in the range [.lit]#@0001-01-01T00:00:00.0# to [.lit]#@9999-12-31T23:59:59.999# with a 1 millisecond step size. Note that DateTime values may also optionally indicate an offset.

[[decimal-1]]
=== Decimal

*Definition:*

[source,cql]
----
simple type Decimal
----

*Description:*

The [.id]#Decimal# type represents real values within CQL.

CQL supports decimal values in the range [.lit]#-10^28^-10^-8^# to [.lit]#10^28^-10^-8^# with a step size of [.lit]#10^-8^#.

[[integer-1]]
=== Integer

*Definition:*

[source,cql]
----
simple type Integer
----

*Description:*

The [.id]#Integer# type represents whole number values within CQL.

CQL supports integer values in the range [.lit]#-2^31^# to [.lit]#2^31^-1# with a step size of [.lit]#1#.

[[quantity]]
=== Quantity

*Definition:*

[source,cql]
----
structured type Quantity
{
  value Decimal
  unit String
}
----

*Description:*

The [.id]#Quantity# type represents quantities with a specified unit within CQL. The unit must be a valid UCUM unit or CQL temporal keyword. UCUM units in CQL use the case-sensitive (c/s) form. When a quantity value has no unit specified, operations are performed with the default UCUM unit ('1'). The value element of a Quantity must be present.

[[ratio]]
==== Ratio

*Definition:*

[source,cql]
----
structured type Ratio
{
  numerator Quantity
  denominator Quantity
}
----

*Description:*

The [.id]#Ratio# type represents a relationship between two quantities, such as a titre (e.g. 1:128), or a concentration (e.g. 5 'mg':10'mL'). The numerator and denominator elements must be present (i.e. can not be null).

[[string-1]]
=== String

*Definition:*

[source,cql]
----
simple type String
----

*Description:*

The [.id]#String# type represents string values within CQL.

CQL supports string values up to [.lit]#2^31^-1# characters in length.

For string literals, CQL uses standard escape sequences:

[cols=",",options="header",]
|========================================================================================
|Escape |Character
|\' |Single-quote
|\" |Double-quote
|\r |Carriage Return
|\n |Line Feed
|\t |Tab
|\f |Form Feed
|\\ |Backslash
|\uXXXX |Unicode character, where XXXX is the hexadecimal representation of the character
|========================================================================================

[[time]]
=== Time

*Definition:*

[source,cql]
----
simple type Time
----

*Description:*

The [.id]#Time# type represents time-of-day values within CQL.

CQL supports time values in the range [.lit]#@T00:00:00.0# to [.lit]#@T23:59:59.999# with a step size of 1 millisecond. Not that Time values may also optionally indicate an offset.

[[logical-operators-3]]
== Logical Operators

[[and]]
=== And

*Signature:*

[source,cql]
----
and (left Boolean, right Boolean) Boolean
----

*Description:*

The [.kw]#and# operator returns true if both its arguments are true. If either argument is false, the result is false. Otherwise, the result is null.

The following table defines the truth table for this operator:

[[table-9-a]]
[cols=",,,",options="header",]
|==========================
| |TRUE |FALSE |NULL
|*TRUE*  |TRUE |FALSE |NULL
|*FALSE* |FALSE |FALSE |FALSE
|*NULL*  |NULL |FALSE |NULL
|==========================

Table 9‑A

*Example:*

The following examples illustrate the behavior of the [.kw]#and# operator:

[source,cql]
----
define IsTrue = true and true
define IsFalse = true and false
define IsAlsoFalse = false and null
define IsNull = true and null
----

Note that CQL does not prescribe short-circuit evaluation of logical operators.

[[implies]]
=== Implies

*Signature:*

[source,cql]
----
implies (left Boolean, right Boolean) Boolean
----

*Description:*

The [.kw]#implies# operator returns the logical implication of its arguments. This means that if the left operand evaluates to true, this operator returns the boolean evaluation of the right operand. If the left operand evaluates to false, this operator returns true. Otherwise, this operator returns true if the right operand evaluates to true, and null otherwise.

The following table defines the truth table for this operator:

[[table-9-a1]]
[cols=",,,",options="header",]
|=======================
| |TRUE |FALSE |NULL
|*TRUE* |*TRUE* |*FALSE* |*NULL*
|*FALSE* |*TRUE* |*TRUE* |*TRUE*
|*NULL* |*TRUE* |*NULL* |*NULL*
|=======================

Table 9‑A

[[not]]
=== Not

*Signature:*

[source,cql]
----
not (argument Boolean) Boolean
----

*Description:*

The [.kw]#not# operator returns true if the argument is false and false if the argument is true. Otherwise, the result is null.

The following table defines the truth table for this operator:

[[table-9-b]]
[cols=",",options="header",]
|===========
|  |NOT
|*TRUE* |*FALSE*
|*FALSE* |*TRUE*
|*NULL* |*NULL*
|===========

Table 9‑B

[[or]]
=== Or

*Signature:*

[source,cql]
----
or (left Boolean, right Boolean) Boolean
----

*Description:*

The [.kw]#or# operator returns true if either of its arguments are true. If both arguments are false, the result is false. Otherwise, the result is null.

The following table defines the truth table for this operator:

[[table-9-c]]
[cols=",,,",options="header",]
|========================
| |TRUE |FALSE |NULL
|*TRUE* |*TRUE* |*TRUE* |*TRUE*
|*FALSE* |*TRUE* |*FALSE* |*NULL*
|*NULL* |*TRUE* |*NULL* |*NULL*
|========================

Table 9‑C

*Example:*

The following examples illustrate the behavior of the [.kw]#or# operator:

[source,cql]
----
define IsTrue = true or false
define IsAlsoTrue = true or null
define IsFalse = false or false
define IsNull = false or null
----

Note that CQL does not prescribe short-circuit evaluation of logical operators.

[[xor]]
=== Xor

*Signature:*

[source,cql]
----
xor (left Boolean, right Boolean) Boolean
----

*Description:*

The [.kw]#xor# (exclusive or) operator returns true if one argument is true and the other is false. If both arguments are true or both arguments are false, the result is false. Otherwise, the result is null.

The following table defines the truth table for this operator:

[[table-9-d]]
[cols=",,,",options="header",]
|========================
| |TRUE |FALSE |NULL
|*TRUE* |*FALSE* |*TRUE* |*NULL*
|*FALSE* |*TRUE* |*FALSE* |*NULL*
|*NULL* |*NULL* |*NULL* |*NULL*
|========================

Table 9‑D

[[type-operators-1]]
== Type Operators

[[as]]
=== As

*Signature:*

[source,cql]
----
as<T>(argument Any) T
cast as<T>(argument Any) T
----

*Description:*

The [.kw]#as# operator allows the result of an expression to be cast as a given target type. This allows expressions to be written that are statically typed against the expected run-time type of the argument.

If the argument is not of the specified type at run-time the result is [.kw]#null#.

The [.kw]#cast# prefix indicates that if the argument is not of the specified type at run-time then an exception is thrown.

*Example:*

The following examples illustrate the use of the [.kw]#as# operator.

[source,cql]
----
define AllProcedures: [Procedure]

define ImagingProcedures:
  AllProcedures P
    where P is ImagingProcedure
    return P as ImagingProcedure

define RuntimeError:
  ImagingProcedures P
    return cast P as Observation
----

[[children]]
=== Children

*Signature:*

[source,cql]
----
Children(argument Any) List<Any>
----

*Description:*

For structured types, the [.id]#Children# operator returns a list of all the values of the elements of the type. List-valued elements are expanded and added to the result individually, rather than as a single list.

For list types, the result is the same as invoking [.id]#Children# on each element in the list and flattening the resulting lists into a single result.

If the source is null, the result is null.

[[convert]]
=== Convert

*Signature:*

[source,cql]
----
convert to<T>(argument Any) T
----

*Description:*

The [.kw]#convert# operator converts a value to a specific type. The result of the operator is the value of the argument converted to the target type, if possible. If there is no valid conversion from the actual value to the target type, the result is null.

The following table lists the conversions supported in CQL:

[[table-9-e]]
[cols=",,,,,,,,,,,,",options="header",]
|===============================================================================================
|From\To |Boolean |Integer |Decimal |Quantity |Ratio |String |Date |DateTime |Time |Code |Concept |List<Code>
|*Boolean* |N/A |- |- |- |- |Explicit |- |- |- |- |- |-
|*Integer* |- |N/A |Implicit |Implicit |- |Explicit |- |- |- |- |- |-
|*Decimal* |- |- |N/A |Implicit |- |Explicit |- |- |- |- |- |-
|*Quantity* |- |- |- |N/A |- |Explicit |- |- |- |- |- |-
|*Ratio* |- |- |- |- |N/A |Explicit |- |- |- |- |- |-
|*String* |Explicit |Explicit |Explicit |Explicit |Explicit |N/A |Explicit |Explicit |Explicit |- |- |-
|*Date* |- |- |- |- |- |Explicit |N/A |Implicit |- |- |- |-
|*DateTime* |- |- |- |- |- |Explicit |- |N/A |- |- |- |-
|*Time* |- |- |- |- |- |Explicit |- |- |N/A |- |- |-
|*Code* |- |- |- |- |- |- |- |- |- |N/A |Implicit |-
|*Concept* |- |- |- |- |- |- |- |- |- |- |N/A |Explicit
|*List<Code>* | | | | | | | | | | |Explicit |N/A
|===============================================================================================

Table 9‑E

For conversions between date/time and string values, ISO-8601 standard format is used:

yyyy-MM-ddThh:mm:ss.fff(Z [.sym]#|# [.sym]#+/-# hh:mm)

For example, the following are valid string representations for date/time values:

[source,cql]
----
'2014-01-01T14:30:00.0Z' // January 1st, 2014, 2:30PM UTC +
'2014-01-01T14:30:00.0-07:00' // January 1st, 2014, 2:30PM Mountain Standard (GMT-7:00) +
'T14:30:00.0Z' // 2:30PM UTC +
'T14:30:00.0-07:00' // 2:30PM Mountain Standard (GMT-7:00)
----

For specific semantics for each conversion, refer to the <<03-developersguide.adoc#explicit-conversion,explicit conversion>> operator documentation.

[[descendents]]
=== Descendents

*Signature:*

[source,cql]
----
Descendents(argument Any) List<Any>
----

*Description:*

For structured types, the [.id]#Descendents# operator returns a list of all the values of the elements of the type, recursively. List-valued elements are expanded and added to the result individually, rather than as a single list.

For list types, the result is the same as invoking [.id]#Descendents# on each element in the list and flattening the resulting lists into a single result.

If the source is null, the result is null.

[[is]]
=== Is

*Signature:*

[source,cql]
----
is<T>(argument Any) Boolean
----

*Description:*

The [.kw]#is# operator allows the type of a result to be tested. If the run-time type of the argument is of the type being tested, the result of the operator is [.kw]#true#; otherwise, the result is [.kw]#false#.

[[toboolean]]
=== ToBoolean

*Signature:*

[source,cql]
----
ToBoolean(argument String) Boolean
----

*Description:*

The [.id]#ToBoolean# operator converts the value of its argument to a [.id]#Boolean# value. The operator accepts the following string representations:

[[table-9-f]]
[cols=",",options="header",]
|====================================
|String Representation |Boolean Value
|[.id]#true t yes y 1# |[.kw]#true#
|[.id]#false f no n 0# |[.kw]#false#
|====================================

Table 9‑F

Note that the operator will ignore case when interpreting the string as a [.id]#Boolean# value.

If the input cannot be interpreted as a valid [.id]#Boolean# value, the result is [.kw]#null#.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[toconcept]]
=== ToConcept

*Signature:*

[source,cql]
----
ToConcept(argument Code) Concept
----

*Description:*

The [.id]#ToConcept# operator converts a value of type [.id]#Code# to a [.id]#Concept# value with the given [.id]#Code# as its primary and only [.id]#Code#. If the [.id]#Code# has a [.id]#display# value, the resulting [.id]#Concept# will have the same [.id]#display# value.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[todate]]
=== ToDate

*Signature:*

[source,cql]
----
ToDate(argument String) DateTime
----

*Description:*

The [.id]#ToDate# operator converts the value of its argument to a [.id]#Date# value. The operator expects the string to be formatted using the ISO-8601 date representation:

YYYY-MM-DD

In addition, the string must be interpretable as a valid date value.

For example, the following are valid string representations for date values:

[source,cql]
----
'2014-01' // January, 2014
'2014-01-01' // January 1st, 2014
----

If the input string is not formatted correctly, or does not represent a valid date value, the result is [.kw]#null#.

As with date literals, date values may be specified to any precision.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[todatetime]]
=== ToDateTime

*Signature:*

[source,cql]
----
ToDateTime(argument Date) DateTime
ToDateTime(argument String) DateTime
----

*Description:*

The [.id]#ToDateTime# operator converts the value of its argument to a [.id]#DateTime# value.

For the string overload, the operator expects the string to be formatted using the ISO-8601 date/time representation:

YYYY-MM-DDThh:mm:ss.fff([.sym]#+|-#)hh:mm
or
YYYY-MM-DDThh:mm:ss.fffZ

In addition, the string must be interpretable as a valid date/time value.

For example, the following are valid string representations for date/time values:

[source,cql]
----
'2014-01-01' // January 1st, 2014
'2014-01-01T14:30:00.0Z' // January 1st, 2014, 2:30PM UTC
'2014-01-01T14:30:00.0-07:00' // January 1st, 2014, 2:30PM Mountain Standard (GMT-7:00)
----

If the input string is not formatted correctly, or does not represent a valid date/time value, the result is [.kw]#null#.

As with date/time literals, date/time values may be specified to any precision. If no timezone offset is supplied, the timezone offset of the evaluation request timestamp is assumed.

For the [.id]#Date# overload, the result will be a [.id]#DateTime# with the time components set to zero, except for the timezone offset, which will be set to the timezone offset of the evaluation request timestamp.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[todecimal]]
=== ToDecimal

*Signature:*

[source,cql]
----
ToDecimal(argument String) Decimal
----

*Description:*

The [.id]#ToDecimal# operator converts the value of its argument to a [.id]#Decimal# value. The operator accepts strings using the following format:

[source,cql]
----
(+|-)?#0(.0#)?
----

Meaning an optional polarity indicator, followed by any number of digits (including none), followed by at least one digit, followed optionally by a decimal point, at least one digit, and any number of additional digits (including none).

Note that the decimal value returned by this operator must be limited in precision and scale to the maximum precision and scale representable for [.id]#Decimal# values within CQL.

If the input string is not formatted correctly, or cannot be interpreted as a valid [.id]#Decimal# value, the result is [.kw]#null#.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[tointeger]]
=== ToInteger

*Signature:*

[source,cql]
----
ToInteger(argument String) Integer
----

*Description:*

The [.id]#ToInteger# operator converts the value of its argument to an [.id]#Integer# value. The operator accepts strings using the following format:

[source,cql]
----
(+|-)?#0
----

Meaning an optional polarity indicator, followed by any number of digits (including none), followed by at least one digit.

Note that the integer value returned by this operator must be a valid value in the range representable for [.id]#Integer# values in CQL.

If the input string is not formatted correctly, or cannot be interpreted as a valid [.id]#Integer# value, the result is [.kw]#null#.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[toquantity]]
=== ToQuantity

*Signature:*

[source,cql]
----
ToQuantity(argument Decimal) Quantity
ToQuantity(argument Integer) Quantity
ToQuantity(argument String) Quantity
----

*Description:*

The [.id]#ToQuantity# operator converts the value of its argument to a [.id]#Quantity# value.

For the [.id]#String# overload, the operator accepts strings using the following format:

[source,cql]
----
(+|-)?#0(.0#)?('<unit>')?
----

Meaning an optional polarity indicator, followed by any number of digits (including none) followed by at least one digit, optionally followed by a decimal point, at least one digit, and any number of additional digits, all optionally followed by a unit designator as a string literal specifying a valid, case-sensitive UCUM unit of measure. Spaces are allowed between the quantity value and the unit designator.

Note that the decimal value of the quantity returned by this operator must be a valid value in the range representable for [.id]#Decimal# values in CQL.

If the input string is not formatted correctly, or cannot be interpreted as a valid [.id]#Quantity# value, the result is [.kw]#null#.

For the [.id]#Integer# and [.id]#Decimal# overloads, the operator returns a quantity with the value of the argument and a unit of '[.lit]#1#' (the default unit).

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[toratio]]
==== ToRatio

*Signature:*

[source,cql]
----
ToRatio(argument String) Ratio
----

*Description:*

The [.id]#ToRatio# operator converts the value of its argument to a [.id]#Ratio# value. The operator accepts strings using the following format:

[source,cql]
----
<quantity>:<quantity>
----

where <quantity> is the format used to by the [.id]#ToQuantity# operator.

If the input string is not formatted correctly, or cannot be interpreted as a valid [.id]#Ratio# value, the result is [.kw]#null#.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[tostring]]
=== ToString

*Signature:*

[source,cql]
----
ToString(argument Boolean) String
ToString(argument Integer) String
ToString(argument Decimal) String
ToString(argument Quantity) String
ToString(argument Ratio) String
ToString(argument Date) String
ToString(argument DateTime) String
ToString(argument Time) String
----

*Description:*

The [.id]#ToString# operator converts the value of its argument to a [.id]#String# value. The operator uses the following string representations for each type:

[[table-9-g]]
[cols=",",options="header",]
|===========================================
|Type |String Representation
|[.id]#Boolean# |[.kw]#true\|false#
|[.id]#Integer# |([.sym]#-#)?#0
|[.id]#Decimal# |([.sym]#-#)?\#0.0#
|[.id]#Quantity# |([.sym]#-#)?\#0.0# '<unit>'
|[.id]#Ratio# |<quantity>:<quantity>
|[.id]#Date# |YYYY-MM-DD
|[.id]#DateTime# |YYYY-MM-DDThh:mm:ss.fff([.sym]#+\|-#)hh:mm
|[.id]#Time# |Thh:mm:ss.fff([.sym]#+\|-#)hh:mm
|===========================================

Table 9‑G

The result of any ToString must be round-trippable back to the source value.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[totime]]
=== ToTime

*Signature:*

[source,cql]
----
ToTime(argument String) Time
----

*Description:*

The [.id]#ToTime# operator converts the value of its argument to a [.id]#Time# value. The operator expects the string to be formatted using ISO-8601 time representation:

Thh:mm:ss.fff([.sym]#+|-#)hh:mm
or
Thh:mm:ss.fffZ

In addition, the string must be interpretable as a valid time-of-day value.

For example, the following are valid string representations for time-of-day values:

[source,cql]
----
'T14:30:00.0Z' // 2:30PM UTC
'T14:30:00.0-07:00' // 2:30PM Mountain Standard (GMT-7:00)
----

If the input string is not formatted correctly, or does not represent a valid time-of-day value, the result is [.kw]#null#.

As with time-of-day literals, time-of-day values may be specified to any precision. If no timezone offset is supplied, the timezone offset of the evaluation request timestamp is assumed.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[nullological-operators-3]]
== Nullological Operators

[[coalesce]]
=== Coalesce

*Signature:*

[source,cql]
----
Coalesce<T>(argument1 T, argument2 T) T
Coalesce<T>(argument1 T, argument2 T, argument3 T) T
Coalesce<T>(argument1 T, argument2 T, argument3 T, argument4 T) T
Coalesce<T>(argument1 T, argument2 T, argument3 T, argument4 T, argument5 T) T
Coalesce<T>(arguments List<T>) T
----

*Description:*

The [.id]#Coalesce# operator returns the first non-null result in a list of arguments. If all arguments evaluate to [.kw]#null#, the result is [.kw]#null#.

The static type of the first argument determines the type of the result, and all subsequent arguments must be of that same type.

[[isnull]]
=== IsNull

*Signature:*

[source,cql]
----
is null(argument Any) Boolean
----

*Description:*

The [.kw]#is null# operator determines whether or not its argument evaluates to [.kw]#null#. If the argument evaluates to [.kw]#null#, the result is [.kw]#true#; otherwise, the result is [.kw]#false#.

[[isfalse]]
=== IsFalse

*Signature:*

[source,cql]
----
is false(argument Boolean) Boolean
----

*Description:*

The [.kw]#is false# operator determines whether or not its argument evaluates to [.kw]#false#. If the argument evaluates to [.kw]#false#, the result is [.kw]#true#; otherwise, the result is [.kw]#false#.

[[istrue]]
=== IsTrue

*Signature:*

[source,cql]
----
is true(argument Boolean) Boolean
----

*Description:*

The [.kw]#is true# operator determines whether or not its argument evaluates to [.kw]#true#. If the argument evaluates to [.kw]#true#, the result is [.kw]#true#; otherwise, the result is [.kw]#false#.

[[comparison-operators-4]]
== Comparison Operators

[[between]]
=== Between

*Signature:*

[source,cql]
----
between(argument Integer, low Integer, high Integer) Boolean
between(argument Decimal, low Decimal, high Decimal) Boolean
between(argument Quantity, low Quantity, high Quantity) Boolean
between(argument Date, low Date, high Date) Boolean
between(argument DateTime, low DateTime, high DateTime) Boolean
between(argument Time, low Time, high Time) Boolean
between(argument String, low String, high String) Boolean
----

*Description:*

The between operator determines whether the first argument is within a given range, inclusive. If the first argument is greater than or equal to the low argument, and less than or equal to the high argument, the result is [.kw]#true#, otherwise, the result is [.kw]#false#.

For comparisons involving quantities, the dimensions of each quantity must be the same, but not necessarily the unit. For example, units of [.lit]#'cm'# and [.lit]#'m'# are comparable, but units of [.lit]#'cm2'# and [.lit]#'cm'# are not. Attempting to operate on quantities with invalid units will result in a [.kw]#null#.

For comparisons involving date/time values with imprecision, note that the result of the comparison may be [.kw]#null#, depending on whether the values involved are specified to the level of precision used for the comparison.

String comparisons are strictly lexical based on the Unicode value of the individual characters in the string.

If any argument is [.kw]#null#, the result is [.kw]#null#.

[[equal]]
=== Equal

*Signature:*

[source,cql]
----
=<T>(left T, right T) Boolean
----

*Description:*

The _equal_ ([.sym]#=#) operator returns [.kw]#true# if the arguments are equal; [.kw]#false# if the arguments are known unequal, and [.kw]#null# otherwise. Equality semantics are defined to be value-based.

For simple types, this means that equality returns [.kw]#true# if and only if the result of each argument evaluates to the same value.

For string values, equality is strictly lexical based on the Unicode values for the individual characters in the strings.

For decimal values, trailing zeroes are ignored.

For quantities, this means that the dimensions of each quantity must be the same, but not necessarily the unit. For example, units of [.lit]#'cm'# and [.lit]#'m'# are comparable, but units of [.lit]#'cm2'# and [.lit]#'cm'# are not. Attempting to operate on quantities with invalid units will result in a [.kw]#null#. When a quantity has no units specified, it is treated as a quantity with the default unit ('[.lit]#1#').

For tuple types, this means that equality returns [.kw]#true# if and only if the tuples are of the same type, and the values for all elements by name are equal.

For list types, this means that equality returns [.kw]#true# if and only if the lists contain elements of the same type, have the same number of elements, and for each element in the lists, in order, the elements are equal using the same semantics.

For interval types, equality returns [.kw]#true# if and only if the intervals are over the same point type, and they have the same value for the starting and ending points of the interval as determined by the [.id]#Start# and [.id]#End# operators.

For comparisons involving date/time or time values with imprecision, note that the result of the comparison may be [.kw]#null#, depending on whether the values involved are specified to the level of precision used for the comparison.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[equivalent]]
=== Equivalent

*Signature:*

[source,cql]
----
~<T>(left T, right T) Boolean
----

*Description:*

The [.sym]#~# operator returns [.kw]#true# if the arguments are the same value, or if they are both [.kw]#null#; and [.kw]#false# otherwise.

For string values, equivalence is case- and locale-insensitive.

For tuple types, this means that two tuple values are equivalent if and only if the tuples are of the same type, and the values for all elements by name are equivalent.

For list types, this means that two list values are equivalent if and only if the lists contain elements of the same type, have the same number of elements, and for each element in the lists, in order, the elements are equivalent.

For interval types, this means that two intervals are equivalent if and only if the intervals are over the same point type, and the starting and ending points of the intervals as determined by the [.id]#Start# and [.id]#End# operators are equivalent.

For [.id]#Code# values, equivalence is defined based on the code and system elements only. The version and display elements are ignored for the purposes of determining [.id]#Code# equivalence.

For [.id]#Concept# values, equivalence is defined as a non-empty intersection of the codes in each [.id]#Concept#.

Note that this operator will always return [.kw]#true# or [.kw]#false#, even if either or both of its arguments are [.kw]#null#, or contain [.kw]#null# components.

This operator, and the corresponding notion of _equivalence_, are used throughout CQL to define the behavior of membership and containment operators such as [.kw]#in#, [.kw]#contains#, [.kw]#includes#, [.id]#IndexOf()#, etc. This provides consistent and intuitive behavior in the presence of missing information in list and membership contexts.

[[greater]]
=== Greater

*Signature:*

[source,cql]
----
>(left Integer, right Integer) Boolean
>(left Decimal, right Decimal) Boolean
>(left Quantity, right Quantity) Boolean
>(left Date, right Date) Boolean
>(left DateTime, right DateTime) Boolean
>(left Time, right Time) Boolean
>(left String, right String) Boolean
----

*Description:*

The _greater_ ([.sym]#>#) operator returns [.kw]#true# if the first argument is greater than the second argument.

String comparisons are strictly lexical based on the Unicode value of the individual characters in the string.

For comparisons involving quantities, the dimensions of each quantity must be the same, but not necessarily the unit. For example, units of [.lit]#'cm'# and [.lit]#'m'# are comparable, but units of [.lit]#'cm2'# and [.lit]#'cm'# are not. Attempting to operate on quantities with invalid units will result in a [.kw]#null#. When a quantity has no units specified, it is treated as a quantity with the default unit ('[.lit]#1#').

For comparisons involving date/time values with imprecision, note that the result of the comparison may be [.kw]#null#, depending on whether the values involved are specified to the level of precision used for the comparison.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[greater-or-equal]]
=== Greater Or Equal

*Signature:*

[source,cql]
----
>=(left Integer, right Integer) Boolean
>=(left Decimal, right Decimal) Boolean
>=(left Quantity, right Quantity) Boolean
>=(left Date, right Date) Boolean
>=(left DateTime, right DateTime) Boolean
>=(left Time, right Time) Boolean
>=(left String, right String) Boolean
----

*Description:*

The _greater or equal_ ([.sym]#>=#) operator returns [.kw]#true# if the first argument is greater than or equal to the second argument.

String comparisons are strictly lexical based on the Unicode value of the individual characters in the string.

For comparisons involving quantities, the dimensions of each quantity must be the same, but not necessarily the unit. For example, units of [.lit]#'cm'# and [.lit]#'m'# are comparable, but units of [.lit]#'cm2'# and [.lit]#'cm'# are not. Attempting to operate on quantities with invalid units will result in a [.kw]#null#. When a quantity has no units specified, it is treated as a quantity with the default unit ('[.lit]#1#').

For comparisons involving date/time values with imprecision, note that the result of the comparison may be [.kw]#null#, depending on whether the values involved are specified to the level of precision used for the comparison.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[less]]
=== Less

*Signature:*

[source,cql]
----
<(left Integer, right Integer) Boolean
<(left Decimal, right Decimal) Boolean
<(left Quantity, right Quantity) Boolean
<(left Date, right Date) Boolean
<(left DateTime, right DateTime) Boolean
<(left Time, right Time) Boolean
<(left String, right String) Boolean
----

*Description:*

The _less_ ([.sym]#<#) operator returns [.kw]#true# if the first argument is less than the second argument.

String comparisons are strictly lexical based on the Unicode value of the individual characters in the string.

For comparisons involving quantities, the dimensions of each quantity must be the same, but not necessarily the unit. For example, units of [.lit]#'cm'# and [.lit]#'m'# are comparable, but units of [.lit]#'cm2'# and [.lit]#'cm'# are not. Attempting to operate on quantities with invalid units will result in a [.kw]#null#. When a quantity has no units specified, it is treated as a quantity with the default unit ('[.lit]#1#').

For comparisons involving date/time values with imprecision, note that the result of the comparison may be [.kw]#null#, depending on whether the values involved are specified to the level of precision used for the comparison.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[less-or-equal]]
=== Less Or Equal

*Signature:*

[source,cql]
----
<=(left Integer, right Integer) Boolean
<=(left Decimal, right Decimal) Boolean
<=(left Quantity, right Quantity) Boolean
<=(left Date, right Date) Boolean
<=(left DateTime, right DateTime) Boolean
<=(left Time, right Time) Boolean
<=(left String, right String) Boolean
----

*Description:*

The _less or equal_ ([.sym]#\<=#) operator returns [.kw]#true# if the first argument is less than or equal to the second argument.

String comparisons are strictly lexical based on the Unicode value of the individual characters in the string.

For comparisons involving quantities, the dimensions of each quantity must be the same, but not necessarily the unit. For example, units of [.lit]#'cm'# and [.lit]#'m'# are comparable, but units of [.lit]#'cm2'# and [.lit]#'cm'# are not. Attempting to operate on quantities with invalid units will result in a [.kw]#null#. When a quantity has no units specified, it is treated as a quantity with the default unit ('[.lit]#1#').

For comparisons involving date/time values with imprecision, note that the result of the comparison may be [.kw]#null#, depending on whether the values involved are specified to the level of precision used for the comparison.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[not-equal]]
=== Not Equal

*Signature:*

[source,cql]
----
!=<T>(left T, right T) Boolean
----

*Description:*

The _not equal_ ([.sym]#!=#) operator returns [.kw]#true# if its arguments are not the same value.

The _not equal_ operator is a shorthand for invocation of logical negation ([.kw]#not#) of the _equal_ operator.

[[not-equivalent]]
=== Not Equivalent

*Signature:*

[source,cql]
----
!~<T>(left T, right T) Boolean
----

*Description:*

The _not equivalent_ ([.sym]#!~#) operator returns [.kw]#true# if its arguments are not equivalent.

The _not equivalent_ operator is a shorthand for invocation of logical negation ([.kw]#not#) of the _equivalent_ operator.

[[arithmetic-operators-4]]
== Arithmetic Operators

[[abs]]
=== Abs

*Signature:*

[source,cql]
----
Abs(argument Integer) Integer
Abs(argument Decimal) Decimal
Abs(argument Quantity) Quantity
----

*Description:*

The [.id]#Abs# operator returns the absolute value of its argument.

When taking the absolute value of a quantity, the unit is unchanged.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[add]]
=== Add

*Signature:*

[source,cql]
----
+(left Integer, right Integer) Integer
+(left Decimal, right Decimal) Decimal
+(left Quantity, right Quantity) Quantity
----

*Description:*

The _add_ ([.sym]#+#) operator performs numeric addition of its arguments.

When invoked with mixed [.id]#Integer# and [.id]#Decimal# arguments, the [.id]#Integer# argument will be implicitly converted to [.id]#Decimal#.

When adding quantities, the dimensions of each quantity must be the same, but not necessarily the unit. For example, units of [.lit]#'cm'# and [.lit]#'m'# can be added, but units of [.lit]#'cm2'# and [.lit]#'cm'# cannot. The unit of the result will be the most granular unit of either input. Attempting to operate on quantities with invalid units will result in a [.kw]#null#. When a quantity has no units specified, it is treated as a quantity with the default unit ('[.lit]#1#').

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[ceiling]]
=== Ceiling

*Signature:*

[source,cql]
----
Ceiling(argument Decimal) Integer
----

*Description:*

The [.id]#Ceiling# operator returns the first integer greater than or equal to the argument.

When invoked with an [.id]#Integer# argument, the argument will be implicitly converted to [.id]#Decimal#.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[divide]]
=== Divide

*Signature:*

[source,cql]
----
/(left Decimal, right Decimal) Decimal
/(left Quantity, right Decimal) Quantity
/(left Quantity, right Quantity) Quantity
----

*Description:*

The _divide_ ([.sym]#/#) operator performs numeric division of its arguments. Note that this operator is [.id]#Decimal# division; for [.id]#Integer# division, use the _truncated divide_ ([.kw]#div#) operator.

When invoked with [.id]#Integer# arguments, the arguments will be implicitly converted to [.id]#Decimal#.

For division operations involving quantities, the resulting quantity will have the appropriate unit. For example:

[source,cql]
----
12 'cm2' / 3 'cm'
----

In this example, the result will have a unit of [.lit]#'cm'#. Note that when performing division of quantities with the same units, the result will have the default UCUM unit ('[.lit]#1#'). When a quantity has no units specified, it is treated as a quantity with the default unit ('[.lit]#1#').

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[floor]]
=== Floor

*Signature:*

[source,cql]
----
Floor(argument Decimal) Integer
----

*Description:*

The [.id]#Floor# operator returns the first integer less than or equal to the argument.

When invoked with an [.id]#Integer# argument, the argument will be implicitly converted to [.id]#Decimal#.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[exp]]
=== Exp

*Signature:*

[source,cql]
----
Exp(argument Decimal) Decimal
----

*Description:*

The [.id]#Exp# operator raises _e_ to the power of its argument.

When invoked with an [.id]#Integer# argument, the argument will be implicitly converted to [.id]#Decimal#.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[log]]
=== Log

*Signature:*

[source,cql]
----
Log(argument Decimal, base Decimal) Decimal
----

*Description:*

The [.id]#Log# operator computes the logarithm of its first argument, using the second argument as the base.

When invoked with [.id]#Integer# arguments, the arguments will be implicitly converted to [.id]#Decimal#.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[ln]]
=== Ln

*Signature:*

[source,cql]
----
Ln(argument Decimal) Decimal
----

*Description:*

The [.id]#Ln# operator computes the natural logarithm of its argument.

When invoked with an [.id]#Integer# argument, the argument will be implicitly converted to [.id]#Decimal#.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[maximum]]
=== Maximum

*Signature:*

[source,cql]
----
maximum<T>() T
----

*Description:*

The [.kw]#maximum# operator returns the maximum representable value for the given type.

The [.kw]#maximum# operator is defined for the [.id]#Integer#, [.id]#Decimal#, [.id]#Date#, [.id]#DateTime#, and [.id]#Time# types.

For [.id]#Integer#, [.kw]#maximum# returns the maximum signed 32-bit integer, 2^31^ - 1.

For [.id]#Decimal#, [.kw]#maximum# returns the maximum representable decimal value, (10^37^ – 1) / 10^8^ (9999999999999999999999999999.99999999).

For [.id]#Date#, [.kw]#maximum# returns the maximum representable date value, [.id]#Date#([.lit]#9999#, [.lit]#12#, [.lit]#31#).

For [.id]#DateTime#, [.kw]#maximum# returns the maximum representable date/time value, [.id]#DateTime#([.lit]#9999#, [.lit]#12#, [.lit]#31#, [.lit]#23#, [.lit]#59#, [.lit]#59#, [.lit]#999#).

For [.id]#Time#, [.kw]#maximum# returns the maximum representable time value, [.id]#Time#([.lit]#23#, [.lit]#59#, [.it]#59#, [.lit]#999#).

For any other type, attempting to invoke [.kw]#maximum# results in an error.

[[minimum]]
=== Minimum

*Signature:*

[source,cql]
----
minimum<T>() T
----

*Description:*

The [.kw]#minimum# operator returns the minimum representable value for the given type.

The [.kw]#minimum# operator is defined for the [.id]#Integer#, [.id]#Decimal#, [.id]#Date#, [.id]#DateTime#, and [.id]#Time# types.

For [.id]#Integer#, [.kw]#minimum# returns the minimum signed 32-bit integer, -2^31^.

For [.id]#Decimal#, [.kw]#minimum# returns the minimum representable decimal value, (-10^37^ – 1) / 10^8^ (-9999999999999999999999999999.99999999).

For [.id]#Date#, [.kw]#minimum# returns the minimum representable date value, [.id]#DateTime#([.lit]#1#, [.lit]#1#, [.lit]#1#).

For [.id]#DateTime#, [.kw]#minimum# returns the minimum representable date/time value, [.id]#DateTime#([.lit]#1#, [.lit]#1#, [.lit]#1#, [.lit]#0#, [.lit]#0#, [.lit]#0#, [.lit]#0#).

For [.id]#Time#, [.kw]#minimum# returns the minimum representable time value, [.id]#Time#([.lit]#0#, [.lit]#0#, [.lit]#0#, [.lit]#0#).

For any other type, attempting to invoke [.kw]#minimum# results in an error.

[[modulo]]
=== Modulo

*Signature:*

[source,cql]
----
mod(left Integer, right Integer) Integer
mod(left Decimal, right Decimal) Decimal
----

*Description:*

The [.kw]#mod# operator computes the remainder of the division of its arguments.

When invoked with mixed [.id]#Integer# and [.id]#Decimal# arguments, the [.id]#Integer# argument will be implicitly converted to [.id]#Decimal#.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[multiply]]
=== Multiply

*Signature:*

[source,cql]
----
*(left Integer, right Integer) Integer
*(left Decimal, right Decimal) Decimal
*(left Decimal, right Quantity) Quantity
*(left Quantity, right Decimal) Quantity
*(left Quantity, right Quantity) Quantity
----

*Description:*

The _multiply_ ([.sym]#*#) operator performs numeric multiplication of its arguments.

When invoked with mixed [.id]#Integer# and [.id]#Decimal# arguments, the [.id]#Integer# argument will be implicitly converted to [.id]#Decimal#.

For multiplication operations involving quantities, the resulting quantity will have the appropriate unit. For example:

[source,cql]
----
12 'cm' * 3 'cm'
3 'cm' * 12 'cm2'
----

In this example, the first result will have a unit of [.lit]#'cm2'#, and the second result will have a unit of [.lit]#'cm3'#. When a quantity has no units specified, it is treated as a quantity with the default unit ('[.lit]#1#').

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[negate]]
=== Negate

*Signature:*

[source,cql]
----
-(argument Integer) Integer
-(argument Decimal) Decimal
-(argument Quantity) Quantity
----

*Description:*

The _negate_ ([.sym]#-#) operator returns the negative of its argument.

When negating quantities, the unit is unchanged.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[predecessor]]
=== Predecessor

*Signature:*

[source,cql]
----
predecessor of<T>(argument T) T
----

*Description:*

The [.kw]#predecessor# operator returns the predecessor of the argument. For example, the predecessor of 2 is 1. If the argument is already the minimum value for the type, a run-time error is thrown.

The [.kw]#predecessor# operator is defined for the [.id]#Integer#, [.id]#Decimal#, [.id]#Quantity#, [.id]#Date#, [.id]#DateTime#, and [.id]#Time# types.

For [.id]#Integer#, [.kw]#predecessor# is equivalent to subtracting 1.

For [.id]#Decimal#, [.kw]#predecessor# is equivalent to subtracting the minimum precision value for the [.id]#Decimal# type, or 10^-08^.

For [.id]#Date#, [.id]#DateTime#, and [.id]#Time# values, [.kw]#predecessor# is equivalent to subtracting a time-unit quantity for the lowest specified precision of the value. For example, if the [.id]#DateTime# is fully specified, [.kw]#predecessor# is equivalent to subtracting 1 millisecond; if the [.id]#DateTime# is specified to the second, [.kw]#predecessor# is equivalent to subtracting one second, etc.

For [.id]#Quantity# values, the [.kw]#predecessor# is equivalent to subtracting 1 if the quantity is an integer, and the minimum precision value for the [.id]#Decimal# type if the quantity is a decimal. The units are unchanged.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[power]]
=== Power

*Signature:*

[source,cql]
----
^(argument Integer, exponent Integer) Integer
^(argument Decimal, exponent Decimal) Decimal
----

*Description:*

The _power_ ([.sym]#^#) operator raises the first argument to the power given by the second argument.

When invoked with mixed [.id]#Integer# and [.id]#Decimal# arguments, the [.id]#Integer# argument will be implicitly converted to [.id]#Decimal#.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[round]]
=== Round

*Signature:*

[source,cql]
----
Round(argument Decimal) Decimal
Round(argument Decimal, precision Integer) Decimal
----

*Description:*

The [.id]#Round# operator returns the nearest whole number to its argument. The semantics of round are defined as a traditional round, meaning that a decimal value of 0.5 or higher will round to 1.

When invoked with an [.id]#Integer# argument, the argument will be implicitly converted to [.id]#Decimal#.

If the argument is [.kw]#null#, the result is [.kw]#null#.

Precision determines the decimal place at which the rounding will occur. If precision is not specified or [.kw]#null#, 0 is assumed.

[[subtract]]
=== Subtract

*Signature:*

[source,cql]
----
-(left Integer, right Integer) Integer
-(left Decimal, right Decimal) Decimal
-(left Quantity, right Quantity) Quantity
----

*Description:*

The _subtract_ ([.sym]#-#) operator performs numeric subtraction of its arguments.

When invoked with mixed [.id]#Integer# and [.id]#Decimal# arguments, the [.id]#Integer# argument will be implicitly converted to [.id]#Decimal#.

When subtracting quantities, the dimensions of each quantity must be the same, but not necessarily the unit. For example, units of [.lit]#'cm'# and [.lit]#'m'# can be subtracted, but units of [.lit]#'cm2'# and [.lit]#'cm'# cannot. The unit of the result will be the most granular unit of either input. Attempting to operate on quantities with invalid units will result in a [.kw]#null#. When a quantity has no units specified, it is treated as a quantity with the default unit ('[.lit]#1#').

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[successor]]
=== Successor

*Signature:*

[source,cql]
----
successor of<T>(argument T) T
----

*Description:*

The [.kw]#successor# operator returns the successor of the argument. For example, the successor of 1 is 2. If the argument is already the maximum value for the type, a run-time error is thrown.

The [.kw]#successor# operator is defined for the [.id]#Integer#, [.id]#Quantity#, [.id]#Decimal#, [.id]#Date#, [.id]#DateTime#, and [.id]#Time# types.

For [.id]#Integer#, [.kw]#successor# is equivalent to adding 1.

For [.id]#Decimal#, [.kw]#successor# is equivalent to adding the minimum precision value for the [.id]#Decimal# type, or 10^-08^.

For [.id]#Date#, [.id]#DateTime# and [.id]#Time# values, [.kw]#successor# is equivalent to adding a time-unit quantity for the lowest specified precision of the value. For example, if the [.id]#DateTime# is fully specified, [.kw]#successor# is equivalent to adding 1 millisecond; if the [.id]#DateTime# is specified to the second, [.kw]#successor# is equivalent to adding one second, etc.

For [.id]#Quantity# values, the [.kw]#successor# is equivalent to adding 1 if the quantity is an integer, and the minimum precision value for the [.id]#Decimal# type if the quantity is a decimal. The units are unchanged.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[truncate]]
=== Truncate

*Signature:*

[source,cql]
----
Truncate(argument Decimal) Integer
----

*Description:*

The [.id]#Truncate# operator returns the integer component of its argument.

When invoked with an [.id]#Integer# argument, the argument will be implicitly converted to [.id]#Decimal#.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[truncated-divide]]
=== Truncated Divide

*Signature:*

[source,cql]
----
div(left Integer, right Integer) Integer
div(left Decimal, right Decimal) Decimal
----

*Description:*

The [.kw]#div# operator performs truncated division of its arguments.

When invoked with mixed [.id]#Integer# and [.id]#Decimal# arguments, the [.id]#Integer# argument will be implicitly converted to [.id]#Decimal#.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[string-operators-3]]
== String Operators

[[combine]]
=== Combine

*Signature:*

[source,cql]
----
Combine(source List<String>) String
Combine(source List<String>, separator String) String
----

*Description:*

The [.id]#Combine# operator combines a list of strings, optionally separating each string with the given separator.

If either argument is [.kw]#null#, or any element in the source list of strings is [.kw]#null#, the result is [.kw]#null#.

[[concatenate]]
=== Concatenate

*Signature:*

[source,cql]
----
+(left String, right String) String
&(left String, right String) String
----

*Description:*

The _concatenate_ ([.sym]#+# or [.sym]#&#) operator performs string concatenation of its arguments.

When using [.sym]#+#, if either argument is [.kw]#null#, the result is [.kw]#null#.

When using [.sym]#&#, [.kw]#null# arguments are treated as an empty string ([.sym]#''#).

[[endswith]]
=== EndsWith

*Signature:*

[source,cql]
----
EndsWith(argument String, suffix String) Boolean
----

*Description:*

The [.id]#EndsWith# operator returns true if the given string ends with the given suffix.

If the suffix is the empty string, the result is true.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[indexer]]
=== Indexer

*Signature:*

[source,cql]
----
[](argument String, index Integer) String
----

*Description:*

The _indexer_ ([.sym]#[]#) operator returns the character at the indexth position in a string.

Indexes in strings are defined to be 0-based.

If either argument is [.kw]#null#, the result is [.kw]#null#.

If the index is greater than the length of the string being indexed, the result is [.kw]#null#.

[[lastpositionof]]
=== LastPositionOf

*Signature:*

[source,cql]
----
LastPositionOf(pattern String, argument String) Integer
----

*Description:*

The [.id]#LastPositionOf# operator returns the 0-based index of the last appearance of the given pattern in the given string.

If the pattern is not found, the result is -1.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[length]]
=== Length

*Signature:*

[source,cql]
----
Length(argument String) Integer
----

*Description:*

The [.id]#Length# operator returns the number of characters in a string.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[lower]]
=== Lower

*Signature:*

[source,cql]
----
Lower(argument String) String
----

*Description:*

The [.id]#Lower# operator returns the given string with all characters converted to their lower case equivalents.

Note that the definition of _lowercase_ for a given character is a locale-dependent determination, and is not specified by CQL. Implementations are expected to provide appropriate and consistent handling of locale for their environment.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[matches]]
=== Matches

*Signature:*

[source,cql]
----
Matches(argument String, pattern String) Boolean
----

*Description:*

The [.id]#Matches# operator returns true if the given string matches the given regular expression pattern. Regular expressions should function consistently, regardless of any culture- and locale-specific settings in the environment, should be case-sensitive, use single line mode, and allow Unicode characters.

If either argument is [.kw]#null#, the result is [.kw]#null#.

Platforms will typically use native regular expression implementations. These are typically fairly similar, but there will always be small differences. As such, CQL does not prescribe a particular dialect, but recommends the use of the dialect defined as part of XML Schema 1.1 as the dialect most likely to be broadly supported and understood.

[[positionof]]
=== PositionOf

*Signature:*

[source,cql]
----
PositionOf(pattern String, argument String) Integer
----

*Description:*

The [.id]#PositionOf# operator returns the 0-based index of the given pattern in the given string.

If the pattern is not found, the result is -1.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[replacematches]]
=== ReplaceMatches

*Signature:*

[source,cql]
----
Matches(argument String, pattern String, substitution String) String
----

*Description:*

The [.id]#ReplaceMatches# operator matches the given string using the given regular expression pattern, replacing each match with the given substitution. The substitution string may refer to identified match groups in the regular expression. Regular expressions should function consistently, regardless of any culture- and locale-specific settings in the environment, should be case-sensitive, use single line mode, and allow Unicode characters.

If any argument is [.kw]#null#, the result is [.kw]#null#.

Platforms will typically use native regular expression implementations. These are typically fairly similar, but there will always be small differences. As such, CQL does not prescribe a particular dialect, but recommends the use of the dialect defined as part of XML Schema 1.1 as the dialect most likely to be broadly supported and understood.

[[split]]
=== Split

*Signature:*

[source,cql]
----
Split(stringToSplit String, separator String) List<String>
----

*Description:*

The [.id]#Split# operator splits a string into a list of strings using a separator.

If the [.id]#stringToSplit# argument is [.kw]#null#, the result is [.kw]#null#.

If the [.id]#stringToSplit# argument does not contain any appearances of the separator, the result is a list of strings containing one element that is the value of the [.id]#stringToSplit# argument.

[[startswith]]
=== StartsWith

*Signature:*

[source,cql]
----
StartsWith(argument String, prefix String) Boolean
----

*Description:*

The [.id]#StartsWith# operator returns true if the given string starts with the given prefix.

If the prefix is the empty string, the result is true.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[substring]]
=== Substring

*Signature:*

[source,cql]
----
Substring(stringToSub String, startIndex Integer) String
Substring(stringToSub String, startIndex Integer, length Integer) String
----

*Description:*

The [.id]#Substring# operator returns the string within [.id]#stringToSub#, starting at the 0-based index [.id]#startIndex#, and consisting of [.id]#length# characters.

If [.id]#length# is ommitted, the substring returned starts at [.id]#startIndex# and continues to the end of [.id]#stringToSub#.

If [.id]#stringToSub# or [.id]#startIndex# is [.kw]#null#, or [.id]#startIndex# is out of range, the result is [.kw]#null#.

[[upper]]
=== Upper

*Signature:*

[source,cql]
----
Upper(argument String) String
----

*Description:*

The [.id]#Upper# operator returns the given string with all characters converted to their upper case equivalents.

Note that the definition of _uppercase_ for a given character is a locale-dependent determination, and is not specified by CQL. Implementations are expected to provide appropriate and consistent handling of locale for their environment.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[datetime-operators-2]]
== Date/Time Operators

[[add-1]]
=== Add

*Signature:*

[source,cql]
----
+(left Date, right Quantity) Date
+(left DateTime, right Quantity) DateTime
+(left Time, right Quantity) Time
----

*Description:*

The _add_ ([.sym]#+#) operator returns the value of the given date/time, incremented by the time-valued quantity, respecting variable length periods for calendar years and months.

For [.id]#Date# values, the quantity unit must be one of: [.kw]#years#, [.kw]#months#, [.kw]#weeks#, or [.kw]#days#.

For [.id]#DateTime# values, the quantity unit must be one of: [.kw]#years#, [.kw]#months#, [.kw]#weeks#, [.kw]#days#, [.kw]#hours#, [.kw]#minutes#, [.kw]#seconds#, or [.kw]#milliseconds#.

For [.id]#Time# values, the quantity unit must be one of: [.kw]#hours#, [.kw]#minutes#, [.kw]#seconds#, or [.kw]#milliseconds#.

Note that the quantity units may be specified in singular, plural, or UCUM form.

The operation is performed by converting the time-based quantity to the highest specified granularity in the date/time value (truncating any resulting decimal portion) and then adding it to the date/time value. For example, the following addition:

DateTime(2014) + 24 months

This example results in the value [.id]#DateTime(2016)# even though the date/time value is not specified to the level of precision of the time-valued quantity.

Note also that this means that if decimals appear in the time-valued quantities, the fractional component will be ignored.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[after]]
=== After

*Signature:*

[source,cql]
----
after _precision_ of(left Date, right Date) Boolean
after _precision_ of(left DateTime, right DateTime) Boolean
after _precision_ of(left Time, right Time) Boolean
----

*Description:*

The [.kw]#after#__-precision-__[.kw]#of# operator compares two date/time values to the specified precision to determine whether the first argument is the after the second argument.

For [.id]#Date# values, _precision_ must be one of: [.kw]#year#, [.kw]#month#, [.kw]#week#, or [.kw]#day#.

For [.id]#DateTime# values, _precision_ must be one of: [.kw]#year#, [.kw]#month#, [.kw]#week#, [.kw]#day#, [.kw]#hour#, [.kw]#minute#, [.kw]#second#, or [.kw]#millisecond#.

For [.id]#Time# values, _precision_ must be one of: [.kw]#hour#, [.kw]#minute#, [.kw]#second#, or [.kw]#millisecond#.

For comparisons involving date/time or time values with imprecision, note that the result of the comparison may be [.kw]#null#, depending on whether the values involved are specified to the level of precision used for the comparison.

As with all date/time calculations, comparisons are performed respecting the timezone offset.

If either or both arguments are [.kw]#null#, the result is [.kw]#null#.

[[before]]
=== Before

*Signature:*

[source,cql]
----
before _precision_ of(left Date, right Date) Boolean
before _precision_ of(left DateTime, right DateTime) Boolean
before _precision_ of(left Time, right Time) Boolean
----

*Description:*

The [.kw]#before#__-precision-__[.kw]#of# operator compares two date/time values to the specified precision to determine whether the first argument is the before the second argument.

For [.id]#Date# values, _precision_ must be one of: [.kw]#year#, [.kw]#month#, [.kw]#week#, or [.kw]#day#.

For [.id]#DateTime# values, _precision_ must be one of: [.kw]#year#, [.kw]#month#, [.kw]#week#, [.kw]#day#, [.kw]#hour#, [.kw]#minute#, [.kw]#second#, or [.kw]#millisecond#.

For [.id]#Time# values, _precision_ must be one of: [.kw]#hour#, [.kw]#minute#, [.kw]#second#, or [.kw]#millisecond#.

For comparisons involving date/time or time values with imprecision, note that the result of the comparison may be [.kw]#null#, depending on whether the values involved are specified to the level of precision used for the comparison.

As with all date/time calculations, comparisons are performed respecting the timezone offset.

If either or both arguments are [.kw]#null#, the result is [.kw]#null#.

[[date-1]]
=== Date

*Signature:*

[source,cql]
----
Date(year Integer) Date
Date(year Integer, month Integer) Date
Date(year Integer, month Integer, day Integer) Date
----

*Description:*

The [.id]#Date# operator constructs a date value from the given components.

At least one component must be specified, and no component may be specified at a precision below an unspecified precision. For example, [.id]#month# may be [.kw]#null#, but if it is, [.id]#day# must be [.kw]#null# as well.

[[datetime-1]]
=== DateTime

*Signature:*

[source,cql]
----
DateTime(year Integer) DateTime
DateTime(year Integer, month Integer) DateTime
DateTime(year Integer, month Integer, day Integer) DateTime
DateTime(year Integer, month Integer, day Integer,
  hour Integer) DateTime
DateTime(year Integer, month Integer, day Integer,
  hour Integer, minute Integer) DateTime
DateTime(year Integer, month Integer, day Integer,
  hour Integer, minute Integer, second Integer) DateTime
DateTime(year Integer, month Integer, day Integer,
  hour Integer, minute Integer, second Integer, millisecond Integer) DateTime
DateTime(year Integer, month Integer, day Integer,
  hour Integer, minute Integer, second Integer, millisecond Integer,
  timezoneOffset Decimal) DateTime
----

*Description:*

The [.id]#DateTime# operator constructs a date/time value from the given components.

At least one component other than [.id]#timezoneOffset# must be specified, and no component may be specified at a precision below an unspecified precision. For example, [.id]#hour# may be [.kw]#null#, but if it is, [.id]#minute#, [.id]#second#, and [.id]#millisecond# must all be [.kw]#null# as well.

If [.id]#timezoneOffset# is not specified, it is defaulted to the timezone offset of the evaluation request.

[[datetime-component-from]]
=== Date/Time Component From

*Signature:*

[source,cql]
----
_precision_ from(argument Date) Integer
_precision_ from(argument DateTime) Integer
_precision_ from(argument Time) Integer
timezone from(argument DateTime) Decimal
timezone from(argument Time) Decimal
date from(argument DateTime) Date
time from(argument DateTime) Time
----

*Description:*

The _component_-[.kw]#from# operator returns the specified component of the argument.

For [.id]#Date# values, _precision_ must be one of: [.kw]#year#, [.kw]#month#, or [.kw]#day#.

For [.id]#DateTime# values, _precision_ must be one of: [.kw]#year#, [.kw]#month#, [.kw]#day#, [.kw]#hour#, [.kw]#minute#, [.kw]#second#, or [.kw]#millisecond#.

For [.id]#Time# values, _precision_ must be one of: [.kw]#hour#, [.kw]#minute#, [.kw]#second#, or [.kw]#millisecond#.

If the argument is [.kw]#null#, or is not specified to the level of precision being extracted, the result is [.kw]#null#.

[[difference]]
=== Difference

*Signature:*

[source,cql]
----
difference in _precision_ between(low Date, high Date) Integer
difference in _precision_ between(low DateTime, high DateTime) Integer
difference in _precision_ between(low Time, high Time) Integer
----

*Description:*

The __difference-__[.kw]#between# operator returns the number of boundaries crossed for the specified precision between the first and second arguments. If the first argument is after the second argument, the result is negative. The result of this operation is always an integer; any fractional boundaries are dropped.

As with all date/time calculations, difference calculations are performed respecting the timezone offset depending on the precision.

For [.id]#Date# values, _precision_ must be one of: [.kw]#years#, [.kw]#months#, [.kw]#weeks#, or [.kw]#days#.

For [.id]#DateTime# values, _precision_ must be one of: [.kw]#years#, [.kw]#months#, [.kw]#weeks#, [.kw]#days#, [.kw]#hours#, [.kw]#minutes#, [.kw]#seconds#, or [.kw]#milliseconds#.

For [.id]#Time# values, _precision_ must be one of: [.kw]#hours#, [.kw]#minutes#, [.kw]#seconds#, or [.kw]#milliseconds#.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[duration]]
=== Duration

*Signature:*

[source,cql]
----
_duration_ between(low Date, high Date) Integer
_duration_ between(low DateTime, high DateTime) Integer
_duration_ between(low Time, high Time) Integer
----

*Description:*

The __duration-__[.kw]#between# operator returns the number of whole calendar periods for the specified precision between the first and second arguments. If the first argument is after the second argument, the result is negative. The result of this operation is always an integer; any fractional periods are dropped.

For [.id]#Date# values, _duration_ must be one of: [.kw]#years#, [.kw]#months#, [.kw]#weeks#, or [.kw]#days#.

For [.id]#DateTime# values, _duration_ must be one of: [.kw]#years#, [.kw]#months#, [.kw]#weeks#, [.kw]#days#, [.kw]#hours#, [.kw]#minutes#, [.kw]#seconds#, or [.kw]#milliseconds#.

For [.id]#Time# values, _duration_ must be one of: [.kw]#hours#, [.kw]#minutes#, [.kw]#seconds#, or [.kw]#milliseconds#.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[now]]
=== Now

*Signature:*

[source,cql]
----
Now() DateTime
----

*Description:*

The [.id]#Now# operator returns the date and time of the start timestamp associated with the evaluation request. [.id]#Now# is defined in this way for two reasons:

1.  The operation will always return the same value within any given evaluation, ensuring that the result of an expression containing Now will always return the same result.
2.  The operation will return the timestamp associated with the evaluation request, allowing the evaluation to be performed with the same timezone offset information as the data delivered with the evaluation request.

[[same-as-1]]
=== Same As

*Signature:*

[source,cql]
----
same _precision_ as(left Date, right Date) Boolean
same _precision_ as(left DateTime, right DateTime) Boolean
same _precision_ as(left Time, right Time) Boolean
----

*Description:*

The [.kw]#same#__-precision-__[.kw]#as# operator compares two date/time values to the specified precision for equality. Individual component values are compared starting from the year component down to the specified precision. If all values are specified and have the same value for each component, then the result is [.kw]#true#. If a compared component is specified in both dates, but the values are not the same, then the result is [.kw]#false#. Otherwise the result is [.kw]#null#, as there is not enough information to make a determination.

For [.id]#Date# values, _precision_ must be one of: [.kw]#year#, [.kw]#month#, [.kw]#week#, or [.kw]#day#.

For [.id]#DateTime# values, _precision_ must be one of: [.kw]#year#, [.kw]#month#, [.kw]#week#, [.kw]#day#, [.kw]#hour#, [.kw]#minute#, [.kw]#second#, or [.kw]#millisecond#.

For [.id]#Time# values, _precision_ must be one of: [.kw]#hour#, [.kw]#minute#, [.kw]#second#, or [.kw]#millisecond#.

For comparisons involving date/time or time values with imprecision, note that the result of the comparison may be [.kw]#null#, depending on whether the values involved are specified to the level of precision used for the comparison.

As with all date/time calculations, comparisons are performed respecting the timezone offset.

If either or both arguments are [.kw]#null#, the result is [.kw]#null#.

If no precision is specified, [.kw]#millisecond# precision is used.

[[same-or-after]]
=== Same Or After

*Signature:*

[source,cql]
----
same _precision_ or after(left Date, right Date) Boolean
same _precision_ or after(left DateTime, right DateTime) Boolean
same _precision_ or after(left Time, right Time) Boolean
----

*Description:*

The [.kw]#same#__-precision-__[.kw]#or after# operator compares two date/time values to the specified precision to determine whether the first argument is the same or after the second argument.

For [.id]#Date# values, _precision_ must be one of: [.kw]#year#, [.kw]#month#, [.kw]#week#, or [.kw]#day#.

For [.id]#DateTime# values, _precision_ must be one of: [.kw]#year#, [.kw]#month#, [.kw]#week#, [.kw]#day#, [.kw]#hour#, [.kw]#minute#, [.kw]#second#, or [.kw]#millisecond#.

For [.id]#Time# values, _precision_ must be one of: [.kw]#hour#, [.kw]#minute#, [.kw]#second#, or [.kw]#millisecond#.

For comparisons involving date/time or time values with imprecision, note that the result of the comparison may be [.kw]#null#, depending on whether the values involved are specified to the level of precision used for the comparison.

As with all date/time calculations, comparisons are performed respecting the timezone offset.

If either or both arguments are [.kw]#null#, the result is [.kw]#null#.

If no precision is specified, the [.kw]#millisecond# precision is used.

Note that in timing phrases, the keyword [.kw]#on# may be used as a synonym for [.kw]#same# for this operator.

[[same-or-before]]
=== Same Or Before

*Signature:*

[source,cql]
----
same _precision_ or before(left Date, right Date) Boolean
same _precision_ or before(left DateTime, right DateTime) Boolean
same _precision_ or before(left Time, right Time) Boolean
----

*Description:*

The [.kw]#same#__-precision-__[.kw]#or before# operator compares two date/time values to the specified precision to determine whether the first argument is the same or before the second argument.

For [.id]#Date# values, _precision_ must be one of: [.kw]#year#, [.kw]#month#, [.kw]#week#, or [.kw]#day#.

For [.id]#DateTime# values, _precision_ must be one of: [.kw]#year#, [.kw]#month#, [.kw]#week#, [.kw]#day#, [.kw]#hour#, [.kw]#minute#, [.kw]#second#, or [.kw]#millisecond#.

For [.id]#Time# values, _precision_ must be one of: [.kw]#hour#, [.kw]#minute#, [.kw]#second#, or [.kw]#millisecond#.

For comparisons involving date/time or time values with imprecision, note that the result of the comparison may be [.kw]#null#, depending on whether the values involved are specified to the level of precision used for the comparison.

As with all date/time calculations, comparisons are performed respecting the timezone offset.

If either or both arguments are [.kw]#null#, the result is null.

If no precision is specified, the [.kw]#millisecond# precision is used.

Note that in timing phrases, the keyword [.kw]#on# may be used as a synonym for [.kw]#same# for this operator.

[[subtract-1]]
=== Subtract

*Signature:*

[source,cql]
----
-(left Date, right Quantity) Date
-(left DateTime, right Quantity) DateTime
-(left Time, right Quantity) Time
----

*Description:*

The _subtract_ ([.sym]#-#) operator returns the value of the given date/time, decremented by the time-valued quantity, respecting variable length periods for calendar years and months.

For [.id]#Date# values, the quantity unit must be one of: [.kw]#years#, [.kw]#months#, [.kw]#weeks#, or [.kw]#days#.

For [.id]#DateTime# values, the quantity unit must be one of: [.kw]#years#, [.kw]#months#, [.kw]#weeks#, [.kw]#days#, [.kw]#hours#, [.kw]#minutes#, [.kw]#seconds#, or [.kw]#milliseconds#.

For [.id]#Time# values, the quantity unit must be one of: [.kw]#hours#, [.kw]#minutes#, [.kw]#seconds#, or [.kw]#milliseconds#.

Note that the quantity units may be specified in singular, plural or UCUM form.

The operation is performed by converting the time-based quantity to the highest specified granularity in the date/time value (truncating any resulting decimal portion) and then subtracting it from the date/time value. For example, the following subtraction:

[.id]#DateTime(2014)# [.sym]#-# [.lit]#24# [.id]#months#

This example results in the value [.id]#DateTime(2012)# even though the date/time value is not specified to the level of precision of the time-valued quantity.

Note also that this means that if decimals appear in the time-valued quantities, the fractional component will be ignored.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[time-1]]
=== Time

*Signature:*

[source,cql]
----
Time(hour Integer) Time
Time(hour Integer, minute Integer) Time
Time(hour Integer, minute Integer, second Integer) Time
Time(hour Integer, minute Integer, second Integer, millisecond Integer) Time
Time(hour Integer, minute Integer, second Integer, millisecond Integer,
timezoneOffset Decimal) Time
----

*Description:*

The [.id]#Time# operator constructs a time value from the given components.

At least one component other than [.id]#timezoneOffset# must be specified, and no component may be specified at a precision below an unspecified precision. For example, [.id]#minute# may be [.kw]#null#, but if it is, [.id]#second#, and [.id]#millisecond# must all be [.kw]#null# as well.

If [.id]#timezoneOffset# is not specified, it is defaulted to the timezone offset of the evaluation request.

[[timeofday]]
=== TimeOfDay

*Signature:*

[source,cql]
----
TimeOfDay() Time
----

*Description:*

The [.id]#TimeOfDay# operator returns the time of day of the start timestamp associated with the evaluation request. See the [.id]#<<Now>># operator for more information on the rationale for defining the [.id]#TimeOfDay# operator in this way.

[[today]]
=== Today

*Signature:*

[source,cql]
----
Today() Date
----

*Description:*

The [.id]#Today# operator returns the date of the start timestamp associated with the evaluation request. See the [.id]#<<Now>># operator for more information on the rationale for defining the [.id]#Today# operator in this way.

[[interval-operators-3]]
== Interval Operators

[[after-1]]
=== After

*Signature:*

[source,cql]
----
after _precision_ (left Interval<T>, right Interval<T>) Boolean
after _precision_ (left T, right Interval<T>) Boolean
after _precision_ (left Interval<T>, right T) Boolean
----

*Description:*

The [.kw]#after# operator for intervals returns [.kw]#true# if the first interval starts after the second one ends. In other words, if the starting point of the first interval is greater than the ending point of the second interval.

For the point-interval overload, the operator returns [.kw]#true# if the given point is greater than the end of the interval.

For the interval-point overload, the operator returns [.kw]#true# if the given interval starts after the given point.

This operator uses the semantics described in the [.id]#<<Start>># and [.id]#<<End>># operators to determine interval boundaries.

If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[before-1]]
=== Before

*Signature:*

[source,cql]
----
before _precision_ (left Interval<T>, right Interval<T>) Boolean
before _precision_ (left T, right Interval<T>) Boolean
before _precision_ (left interval<T>, right T) Boolean
----

*Description:*

The [.kw]#before# operator for intervals returns [.kw]#true# if the first interval ends before the second one starts. In other words, if the ending point of the first interval is less than the starting point of the second interval.

For the point-interval overload, the operator returns [.kw]#true# if the given point is less than the start of the interval.

For the interval-point overload, the operator returns [.kw]#true# if the given interval ends before the given point.

This operator uses the semantics described in the [.id]#<<Start>># and [.id]#<<End>># operators to determine interval boundaries.

If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[collapse]]
=== Collapse

*Signature:*

[source,cql]
----
collapse(argument List<Interval<T>>) List<Interval<T>>
----

*Description:*

The [.kw]#collapse# operator returns the unique set of intervals that completely covers the ranges present in the given list of intervals.

If the list of intervals is empty, the result is empty. If the list of intervals contains a single interval, the result is a list with that interval. If the list of intervals contains nulls, they will be excluded from the resulting list.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[contains]]
=== Contains

*Signature:*

[source,cql]
----
contains _precision_ (argument Interval<T>, point T) Boolean
----

*Description:*

The [.kw]#contains# operator for intervals returns [.kw]#true# if the given point is greater than or equal to the starting point of the interval, and less than or equal to the ending point of the interval. For open interval boundaries, exclusive comparison operators are used. For closed interval boundaries, if the interval boundary is [.kw]#null#, the result of the boundary comparison is considered [.kw]#true#.

If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[end]]
=== End

*Signature:*

[source,cql]
----
end of(argument Interval<T>) T
----

*Description:*

The [.id]#End# operator returns the ending point of an interval.

If the high boundary of the interval is open, this operator returns the [.kw]#predecessor# of the high value of the interval. Note that if the high value of the interval is [.kw]#null#, the result is [.kw]#null#.

If the high boundary of the interval is closed and the high value of the interval is not null, this operator returns the high value of the interval. Otherwise, the result is the maximum value of the point type of the interval.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[ends]]
=== Ends

*Signature:*

[source,cql]
----
ends _precision_ (left Interval<T>, right Interval<T>) Boolean
----

*Description:*

The [.kw]#ends# operator returns [.kw]#true# if the first interval ends the second. More precisely, if the starting point of the first interval is greater than or equal to the starting point of the second, and the ending point of the first interval is equal to the ending point of the second.

This operator uses the semantics described in the [.kw]#<<start>># and [.kw]#<<end>># operators to determine interval boundaries.

If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[equal-1]]
=== Equal

*Signature:*

[source,cql]
----
=(left Interval<T>, right Interval<T>) Boolean
----

*Description:*

The _equal_ ([.sym]#=#) operator for intervals returns [.kw]#true# if and only if the intervals are over the same point type, and they have the same value for the starting and ending points of the intervals as determined by the [.id]#<<Start>># and [.id]#<<End>># operators.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[equivalent-1]]
=== Equivalent

*Signature:*

[source,cql]
----
~(left Interval<T>, right Interval<T>) Boolean
----

*Description:*

The [.sym]#~# operator for intervals returns [.kw]#true# if and only if the intervals are over the same point type, and the starting and ending points of the intervals as determined by the [.id]#<<Start>># and [.id]#<<End>># operators are equivalent.

[[except]]
=== Except

*Signature:*

[source,cql]
----
except(left Interval<T>, right Interval<T>) Interval<T>
----

*Description:*

The [.kw]#except# operator for intervals returns the set difference of two intervals. More precisely, this operator returns the portion of the first interval that does not overlap with the second. Note that to avoid returning an improper interval, if the second argument is properly contained within the first and does not start or end it, this operator returns [.kw]#null#.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[expand]]
=== Expand

*Signature:*

[source,cql]
----
expand(argument List<Interval<T>>, per Quantity) List<Interval<T>>
----

*Description:*

The [.kw]#expand# operator returns the set of intervals of width per for all the intervals in the input.

The per argument must be a quantity value that is compatible with the point type of the input intervals. For numeric intervals, this means a default unit ('[.lit]#1#'). For date/time intervals, this means a temporal duration.

For example:

[source,cql]
----
expand EffectivePeriods per day
----

Note that if the values in the intervals have a higher precision than the per quantity, the higher precision values will be truncated to the granularity specified by the per quantity.

If the list of intervals is empty, the result is empty. If the list of intervals contains [.kw]#nulls#, they will be excluded from the resulting list.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[in]]
=== In

*Signature:*

[source,cql]
----
in _precision_ (point T, argument Interval<T>) Boolean
----

*Description:*

The [.kw]#in# operator for intervals returns [.kw]#true# if the given point is greater than or equal to the starting point of the interval, and less than or equal to the ending point of the interval. For open interval boundaries, exclusive comparison operators are used. For closed interval boundaries, if the interval boundary is [.kw]#null#, the result of the boundary comparison is considered true.

If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[includes]]
=== Includes

*Signature:*

[source,cql]
----
includes _precision_ (left Interval<T>, right Interval<T>) Boolean
includes _precision_ (left Interval<T>, right T) Boolean
----

*Description:*

The [.kw]#includes# operator for intervals returns [.kw]#true# if the first interval completely includes the second. More precisely, if the starting point of the first interval is less than or equal to the starting point of the second interval, and the ending point of the first interval is greater than or equal to the ending point of the second interval.

For the point overload, the operator returns [.kw]#true# if the interval includes (i.e. contains) the point.

This operator uses the semantics described in the [.id]#<<Start>># and [.id]#<<End>># operators to determine interval boundaries.

If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[included-in]]
=== Included In

*Signature:*

[source,cql]
----
included in _precision_ (left Interval<T>, right Interval<T>) Boolean
included in _precision_ (left T, right Interval<T>) Boolean
----

*Description:*

The [.kw]#included in# operator for intervals returns [.kw]#true# if the first interval is completely included in the second. More precisely, if the starting point of the first interval is greater than or equal to the starting point of the second interval, and the ending point of the first interval is less than or equal to the ending point of the second interval.

For the point overload, the operator returns [.kw]#true# if the point is included in (i.e. in) the interval.

This operator uses the semantics described in the [.id]#<<Start>># and [.id]#<<End>># operators to determine interval boundaries.

If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision.

If either argument is [.kw]#null#, the result is [.kw]#null#.

Note that [.kw]#during# is a synonym for included in and may be used to invoke the same operation wherever [.kw]#included in# may appear.

[[intersect]]
=== Intersect

*Signature:*

[source,cql]
----
intersect(left Interval<T>, right Interval<T>) Interval<T>
----

*Description:*

The [.kw]#intersect# operator for intervals returns the intersection of two intervals. More precisely, the operator returns the interval that defines the overlapping portion of both arguments. If the arguments do not overlap, this operator returns [.kw]#null#.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[meets]]
=== Meets

*Signature:*

[source,cql]
----
meets _precision_ (left Interval<T>, right Interval<T>) Boolean
meets before _precision_ (left Interval<T>, right Interval<T>) Boolean
meets after _precision_ (left Interval<T>, right Interval<T>) Boolean
----

*Description:*

The [.kw]#meets# operator returns [.kw]#true# if the first interval ends immediately before the second interval starts, or if the first interval starts immediately after the second interval ends. In other words, if the ending point of the first interval is equal to the predecessor of the starting point of the second, or if the starting point of the first interval is equal to the successor of the ending point of the second.

The [.kw]#meets before# operator returns [.kw]#true# if the first interval ends immediately before the second interval starts, while the [.kw]#meets after# operator returns [.kw]#true# if the first interval starts immediately after the second interval ends.

This operator uses the semantics described in the [.id]#<<Start>># and [.id]#<<End>># operators to determine interval boundaries.

If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[not-equal-1]]
=== Not Equal

*Signature:*

[source,cql]
----
!=(left Interval<T>, right Interval<T>) : Boolean
----

*Description:*

The _not equal_ ([.sym]#!=#) operator for intervals returns [.kw]#true# if its arguments are not the same value.

The _not equal_ operator is a shorthand for invocation of logical negation ([.kw]#not#) of the _equal_ operator.

[[not-equivalent-1]]
=== Not Equivalent

*Signature:*

[source,cql]
----
!~(left Interval<T>, right Interval<T>) : Boolean
----

*Description:*

The _not equivalent_ ([.sym]#!~#) operator for intervals returns [.kw]#true# if its arguments are not equivalent.

The _not equivalent_ operator is a shorthand for invocation of logical negation ([.kw]#not#) of the _equivalent_ operator.

[[on-or-after]]
=== On Or After

*Signature:*

[source,cql]
----
on or after _precision_ (left Interval<T>, right Interval<T>) Boolean
on or after _precision_ (left T, right Interval<T>) Boolean
on or after _precision_ (left Interval<T>, right T) Boolean
----

*Description:*

The [.kw]#on or after# operator for intervals returns [.kw]#true# if the first interval starts on or after the second one ends. In other words, if the starting point of the first interval is greater than or equal to the ending point of the second interval.

For the point-interval overload, the operator returns [.kw]#true# if the given point is greater than or equal to the end of the interval.

For the interval-point overload, the operator returns [.kw]#true# if the given interval starts on or after the given point.

This operator uses the semantics described in the [.id]#<<Start>># and [.id]#<<End>># operators to determine interval boundaries.

If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision.

If either argument is [.kw]#null#, the result is [.kw]#null#.

Note that this operator can be invoked using either the [.kw]#on or after# or the [.kw]#after or on# syntax.

In timing phrases, the keyword [.kw]#same# is a synonym for [.kw]#on#.

[[on-or-before]]
=== On Or Before

*Signature:*

[source,cql]
----
on or before _precision_ (left Interval<T>, right Interval<T>) Boolean
on or before _precision_ (left T, right Interval<T>) Boolean
on or before _precision_ (left interval<T>, right T) Boolean
----

*Description:*

The [.kw]#on or before# operator for intervals returns [.kw]#true# if the first interval ends on or before the second one starts. In other words, if the ending point of the first interval is less than or equal to the starting point of the second interval.

For the point-interval overload, the operator returns [.kw]#true# if the given point is less than or equal to the start of the interval.

For the interval-point overload, the operator returns [.kw]#true# if the given interval ends on or before the given point.

This operator uses the semantics described in the [.id]#<<Start>># and [.id]#<<End>># operators to determine interval boundaries.

If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision.

If either argument is [.kw]#null#, the result is [.kw]#null#.

Note that this operator can be invoked using either the [.kw]#on or before# or the [.kw]#before or on# syntax.

Note that this operator can be invoked using either the [.kw]#on or after# or the [.kw]#after or on# syntax.

In timing phrases, the keyword [.kw]#same# is a synonym for [.kw]#on#.

[[overlaps]]
=== Overlaps

*Signature:*

[source,cql]
----
overlaps _precision_ (left Interval<T>, right Interval<T>) Boolean
overlaps before _precision_ (left Interval<T>, right Interval<T>) Boolean
overlaps after _precision_ (left Interval<T>, right Interval<T>) Boolean
----

*Description:*

The [.kw]#overlaps# operator returns [.kw]#true# if the first interval overlaps the second. More precisely, if the ending point of the first interval is greater than or equal to the starting point of the second interval, and the starting point of the first interval is less than or equal to the ending point of the second interval.

The operator [.kw]#overlaps before# returns [.kw]#true# if the first interval overlaps the second and starts before it, while the [.kw]#overlaps after# operator returns [.kw]#true# if the first interval overlaps the second and ends after it.

This operator uses the semantics described in the [.id]#<<Start>># and [.id]#<<End>># operators to determine interval boundaries.

If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[point-from]]
=== Point From

*Signature:*

[source,cql]
----
point from(argument Interval<T>) : T
----

*Description:*

The [.kw]#point from# operator extracts the single point from a unit interval. If the argument is not a unit interval, a run-time error is thrown.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[properly-includes]]
=== Properly Includes

*Signature:*

[source,cql]
----
properly includes _precision_ (left Interval<T>, right Interval<T>) Boolean
----

*Description:*

The [.kw]#properly includes# operator for intervals returns [.kw]#true# if the first interval completely includes the second and the first interval is strictly larger than the second. More precisely, if the starting point of the first interval is less than or equal to the starting point of the second interval, and the ending point of the first interval is greater than or equal to the ending point of the second interval, and they are not the same interval.

This operator uses the semantics described in the [.id]#<<Start>># and [.id]#<<End>># operators to determine interval boundaries.

If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[properly-included-in]]
=== Properly Included In

*Signature:*

[source,cql]
----
properly included in _precision_ (left Interval<T>, right Interval<T>) Boolean
----

*Description:*

The [.kw]#properly included in# operator for intervals returns [.kw]#true# if the first interval is completely included in the second and the first interval is strictly smaller than the second. More precisely, if the starting point of the first interval is greater than or equal to the starting point of the second interval, and the ending point of the first interval is less than or equal to the ending point of the second interval, and they are not the same interval.

This operator uses the semantics described in the [.id]#<<Start>># and [.id]#<<End>># operators to determine interval boundaries.

If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision.

If either argument is [.kw]#null#, the result is [.kw]#null#.

Note that [.kw]#during# is a synonym for [.kw]#included in#.

[[start]]
=== Start

*Signature:*

[source,cql]
----
start of(argument Interval<T>) T
----

*Description:*

The [.id]#Start# operator returns the starting point of an interval.

If the low boundary of the interval is open, this operator returns the [.kw]#successor# of the low value of the interval. Note that if the low value of the interval is [.kw]#null#, the result is [.kw]#null#.

If the low boundary of the interval is closed and the low value of the interval is not null, this operator returns the low value of the interval. Otherwise, the result is the minimum value of the point type of the interval.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[starts]]
=== Starts

*Signature:*

[source,cql]
----
starts _precision_ (left Interval<T>, right Interval<T>) Boolean
----

*Description:*

The [.kw]#starts# operator returns [.kw]#true# if the first interval starts the second. More precisely, if the starting point of the first is equal to the starting point of the second interval and the ending point of the first interval is less than or equal to the ending point of the second interval.

This operator uses the semantics described in the [.id]#<<Start>># and [.id]#<<End>># operators to determine interval boundaries.

If precision is specified and the point type is a date/time type, comparisons used in the operation are performed at the specified precision.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[union]]
=== Union

*Signature:*

[source,cql]
----
union(left Interval<T>, right Interval<T>) Interval<T>
----

*Description:*

The [.kw]#union# operator for intervals returns the union of the intervals. More precisely, the operator returns the interval that starts at the earliest starting point in either argument, and ends at the latest starting point in either argument. If the arguments do not overlap or meet, this operator returns [.kw]#null#.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[width]]
=== Width

*Signature:*

[source,cql]
----
width of(argument Interval<T>) T
----

*Description:*

The [.kw]#width# operator returns the width of an interval. The result of this operator is equivalent to invoking: ([.kw]#start of# [.id]#argument# [.sym]#–# [.kw]#end of# [.id]#argument#) [.sym]#+# [.id]#_point-size_#.

Note that because CQL defines _duration_ and _difference_ operations for date/time and time valued intervals, _width_ is not defined for intervals of these types.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[list-operators-2]]
== List Operators

[[contains-1]]
=== Contains

*Signature:*

[source,cql]
----
contains(argument List<T>, element T) Boolean
----

*Description:*

The [.kw]#contains# operator for lists returns [.kw]#true# if the given element is in the list.

This operator uses the notion of _equivalence_ to determine whether or not the element being searched for is equivalent to any element in the list. In particular this means that if the list contains a [.kw]#null#, and the element being searched for is [.kw]#null#, the result will be [.kw]#true#.

If the list argument is [.kw]#null#, the result is [.kw]#null#.

If the element argument is [.kw]#null#, the result is [.kw]#true# if the list contains at least one [.kw]#null# element, and [.kw]#false# otherwise.

[[distinct]]
=== Distinct

*Signature:*

[source,cql]
----
distinct(argument List<T>) List<T>
----

*Description:*

The [.kw]#distinct# operator returns the given list with duplicates eliminated.

This operator uses the notion of _equivalence_ to determine whether two elements in the list are the same for the purposes of duplicate elimination. In particular this means that if the list contains multiple [.kw]#null# elements, the result will only contain one [.kw]#null# element.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[equal-2]]
=== Equal

*Signature:*

[source,cql]
----
=(left List<T>, right List<T>) Boolean
----

*Description:*

The _equal_ ([.sym]#=#) operator for lists returns [.kw]#true# if and only if the lists have the same element type, and have the same elements by value, in the same order.

If either argument is [.kw]#null#, or contains null elements, the result is [.kw]#null#.

[[equivalent-2]]
=== Equivalent

*Signature:*

[source,cql]
----
~(left List<T>, right List<T>) Boolean
----

*Description:*

The [.sym]#~# operator for lists returns [.kw]#true# if and only if the lists contain elements of the same type, have the same number of elements, and for each element in the lists, in order, the elements are equivalent.

[[except-1]]
=== Except

*Signature:*

[source,cql]
----
except(left List<T>, right List<T>) List<T>
----

*Description:*

The [.kw]#except# operator returns the set difference of two lists. More precisely, the operator returns a list with the elements that appear in the first operand that do not appear in the second operand.

This operator uses the notion of _equivalence_ to determine whether two elements are the same for the purposes of computing the difference.

The operator is defined with set semantics, meaning that each element will appear in the result at most once, and that there is no expectation that the order of the inputs will be preserved in the results. 

If the left argument is [.kw]#null#, the result is [.kw]#null#. If the right argument is [.kw]#null#, the result is the left argument.

[[exists]]
=== Exists

*Signature:*

[source,cql]
----
exists(argument List<T>) Boolean
----

*Description:*

The [.kw]#exists# operator returns [.kw]#true# if the list contains any non-null elements.

If the argument is [.kw]#null#, the result is [.kw]#false#.

[[flatten]]
=== Flatten

*Signature:*

[source,cql]
----
flatten(argument List<List<T>>) List<T>
----

*Description:*

The [.kw]#flatten# operator flattens a list of lists into a single list.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[first]]
=== First

*Signature:*

[source,cql]
----
First(argument List<T>) T
----

*Description:*

The [.id]#First# operator returns the first element in a list. The operator is equivalent to invoking the indexer with an index of 0.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[in-1]]
=== In

*Signature:*

[source,cql]
----
in(element T, argument List<T>) Boolean
----

*Description:*

The [.kw]#in# operator for lists returns [.kw]#true# if the given element is in the given list.

This operator uses the notion of _equivalence_ to determine whether or not the element being searched for is equivalent to any element in the list. In particular this means that if the list contains a [.kw]#null#, and the element being searched for is [.kw]#null#, the result will be [.kw]#true#.

If the list argument is [.kw]#null#, the result is [.kw]#null#.

If the element argument is [.kw]#null#, the result is [.kw]#true# if the list contains at least one [.kw]#null# element, and [.kw]#false# otherwise.

[[includes-1]]
=== Includes

*Signature:*

[source,cql]
----
includes(left List<T>, right List<T>) Boolean
includes(left List<T>, right T) Boolean
----

*Description:*

The [.kw]#includes# operator for lists returns [.kw]#true# if the first list contains every element of the second list.

For the singleton overload, this operator returns [.kw]#true# if the list includes (i.e. contains) the singleton.

This operator uses the notion of _equivalence_ to determine whether or not two elements are the same.

If the left argument is [.kw]#null#, the result is [.kw]#false#, else if the right argument is [.kw]#null#, the result is [.kw]#true#.

Note that the order of elements does not matter for the purposes of determining inclusion.

[[included-in-1]]
=== Included In

*Signature:*

[source,cql]
----
included in(left List<T>, right list<T>) Boolean
included in(left T, right list<T>) Boolean
----

*Description:*

The [.kw]#included in# operator for lists returns [.kw]#true# if every element of the first list is in the second list.

For the singleton overload, this operator returns [.kw]#true# if the singleton is included in (i.e. in) the list.

This operator uses the notion of _equivalence_ to determine whether or not two elements are the same.

If the left argument is [.kw]#null#, the result is [.kw]#true#, else if the right argument is [.kw]#null#, the result is [.kw]#false#.

Note that the order of elements does not matter for the purposes of determining inclusion.

[[indexer-1]]
=== Indexer

*Signature:*

[source,cql]
----
[](argument List<T>, index Integer) T
----

*Description:*

The _indexer_ ([.sym]#[]#) operator returns the element at the [.id]#index#^th^ position in a list.

Indexes in lists are defined to be 0-based.

If the [.id]#index# is less than 0, or greater than the number of elements in the list, the result is [.kw]#null#.

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[indexof]]
=== IndexOf

*Signature:*

[source,cql]
----
IndexOf(argument List<T>, element T) Integer
----

*Description:*

The [.id]#IndexOf# operator returns the 0-based index of the given element in the given source list.

The operator uses the notion of _equivalence_ to determine the index. The search is linear, and returns the index of the first element that is equivalent to the element being searched for.

If the list is empty, or no element is found, the result is -1.

If the list argument is [.kw]#null#, the result is [.kw]#null#.

[[intersect-1]]
=== Intersect

*Signature:*

[source,cql]
----
intersect(left List<T>, right List<T>) List<T>
----

*Description:*

The [.kw]#intersect# operator for lists returns the intersection of two lists. More precisely, the operator returns a list containing only the elements that appear in both lists.

This operator uses the notion of _equivalence_ to determine whether or not two elements are the same.

The operator is defined with set semantics, meaning that each element will appear in the result at most once, and that there is no expectation that the order of the inputs will be preserved in the results. 

If either argument is [.kw]#null#, the result is [.kw]#null#.

[[last]]
=== Last

*Signature:*

[source,cql]
----
Last(argument List<T>) T
----

*Description:*

The [.id]#Last# operator returns the last element in a list. In a list of length N, the operator is equivalent to invoking the indexer with an index of N [.sym]#-# 1.

If the argument is [.kw]#null#, the result is [.kw]#null#.

[[length-1]]
=== Length

*Signature:*

[source,cql]
----
Length(argument List<T>) Integer
----

*Description:*

The [.id]#Length# operator returns the number of elements in a list.

If the argument is [.kw]#null#, the result is [.kw]#0#.

[[not-equal-2]]
=== Not Equal

*Signature:*

[source,cql]
----
!=(left List<T>, right List<T>) Boolean
----

*Description:*

The _not equal_ ([.sym]#!=#) operator for lists returns [.kw]#true# if its arguments are not the same value.

The _not equal_ operator is a shorthand for invocation of logical negation ([.kw]#not#) of the _equal_ operator.

[[not-equivalent-2]]
=== Not Equivalent

*Signature:*

[source,cql]
----
!~(left List<T>, right List<T>) Boolean
----

*Description:*

The _not equivalent_ ([.sym]#!~#) operator for lists returns [.kw]#true# if its arguments are not equivalent.

The _not equivalent_ operator is a shorthand for invocation of logical negation ([.kw]#not#) of the _equivalent_ operator.

[[properly-includes-1]]
=== Properly Includes

*Signature:*

[source,cql]
----
properly includes(left List<T>, right List<T>) Boolean
----

*Description:*

The [.kw]#properly includes# operator for lists returns [.kw]#true# if the first list contains every element of the second list, and the first list is strictly larger than the second list.

This operator uses the notion of _equivalence_ to determine whether or not two elements are the same.

If the left argument is [.kw]#null#, the result is [.kw]#false#, else if the right argument is [.kw]#null#, the result is [.kw]#true# if the left argument is not empty.

Note that the order of elements does not matter for the purposes of determining inclusion.

[[properly-included-in-1]]
=== Properly Included In

*Signature:*

[source,cql]
----
properly included in(left List<T>, right list<T>) Boolean
----

*Description:*

The [.kw]#properly included in# operator for lists returns [.kw]#true# if every element of the first list is in the second list and the first list is strictly smaller than the second list.

This operator uses the notion of _equivalence_ to determine whether or not two elements are the same.

If the left argument is [.kw]#null#, the result is [.kw]#true# if the right argument is not empty. Otherwise, if the right argument is [.kw]#null#, the result is [.kw]#false#.

Note that the order of elements does not matter for the purposes of determining inclusion.

[[singleton-from]]
=== Singleton From

*Signature:*

[source,cql]
----
singleton from(argument List<T>) T
----

*Description:*

The [.kw]#singleton from# operator extracts a single element from the source list. If the source list is empty, the result is [.kw]#null#. If the source list contains one element, that element is returned. If the list contains more than one element, a run-time error is thrown.

If the source list is [.kw]#null#, the result is [.kw]#null#.

[[skip]]
=== Skip

*Signature:*

[source,cql]
----
Skip(argument List<T>, number Integer) List<T>
----

*Description:*

The [.id]#Skip# operator returns the elements in the list, skipping the first [.id]#number# elements. If the list has less [.id]#number# elements, the result is empty.

If the source list is [.kw]#null#, the result is [.kw]#null#.

If the number of elements is [.kw]#null#, the result is the entire list, no elements are skipped.

If the number of elements is less than zero, the result is an empty list.

[[tail]]
=== Tail

*Signature:*

[source,cql]
----
Tail(argument List<T>) List<T>
----

*Description:*

The [.id]#Tail# operator returns all but the first element from the given list. If the list is empty, the result is empty.

If the source list is [.kw]#null#, the result is [.kw]#null#.

[[take]]
=== Take

*Signature:*

[source,cql]
----
Take(argument List<T>, number Integer) List<T>
----

*Description:*

The [.id]#Take# operator returns the first [.id]#number# elements from the given list. If the list has less than [.id]#number# elements, the result only contains the elements in the list.

If the source list is [.kw]#null#, the result is [.kw]#null#.

If number is [.kw]#null#, or [.lit]#03 or less, the result is an empty list.

[[union-1]]
=== Union

*Signature:*

[source,cql]
----
union(left List<T>, right List<T>) List<T>
----

*Description:*

The [.kw]#union# operator for lists returns a list with all elements from both arguments. Note that duplicates are eliminated during this process; if an element appears in both sources, that element will only appear once in the resulting list. In addition, there is no expectation that the order of elements in the inputs will be preserved in the results.

If either argument is [.kw]#null#, the result is [.kw]#null#.

Note that the union operator can also be invoked with the symbolic operator ([.sym]#|#).

[[aggregate-functions]]
== Aggregate Functions

[[alltrue]]
=== AllTrue

*Signature:*

[source,cql]
----
AllTrue(argument List<Boolean>) Boolean
----

*Description:*

The [.id]#AllTrue# operator returns [.kw]#true# if all the non-null elements in the source are [.kw]#true#.

If the source contains no non-null elements, [.kw]#true# is returned.

If the source is [.kw]#null#, the result is [.kw]#true#.

[[anytrue]]
=== AnyTrue

*Signature:*

[source,cql]
----
AnyTrue(argument List<Boolean>) Boolean
----

*Description:*

The [.id]#AnyTrue# operator returns [.kw]#true# if any non-null element in the source is [.kw]#true#.

If the source contains no non-null elements, [.kw]#false# is returned.

If the source is [.kw]#null#, the result is [.kw]#false#.

[[avg]]
=== Avg

*Signature:*

[source,cql]
----
Avg(argument List<Decimal>) Decimal
Avg(argument List<Quantity>) Quantity
----

*Description:*

The [.id]#Avg# operator returns the average of the non-null elements in the source.

If the source contains no non-null elements, [.kw]#null# is returned.

If the source is [.kw]#null#, the result is [.kw]#null#.

[[count]]
=== Count

*Signature:*

[source,cql]
----
Count(argument List<T>) Integer
----

*Description:*

The [.id]#Count# operator returns the number of non-null elements in the source. If the list contains no non-null elements, the result is 0. If the list is [.kw]#null#, the result is [.kw]#0#.

[[geometricmean]]
=== GeometricMean

*Signature:*

[source,cql]
----
GeometricMean(argument List<Decimal>) Decimal
----

*Description:*

The [.id]#GeometricMean# operator returns the geometric mean of the non-null elements in the source. Geometric mean is defined as the N^th^ root of the geometric product of the elements. In other words:

[source,cql]
----
GeometricMean(X) = Power(Product(X), 1 / Count(X))
----

If the source contains no non-null elements, the result is [.kw]#null#.

If the source is [.kw]#null#, the result is [.kw]#null#.

[[max]]
=== Max

*Signature:*

[source,cql]
----
Max(argument List<Integer>) Integer
Max(argument List<Decimal>) Decimal
Max(argument List<Quantity>) Quantity
Max(argument List<Date>) Date
Max(argument List<DateTime>) DateTime
Max(argument List<Time>) Time
Max(argument List<String>) String
----

*Description:*

The [.id]#Max# operator returns the maximum element in the source. Comparison semantics are defined by the <<Comparison Operators>> for the type of value being aggregated.

If the source contains no non-null elements, [.kw]#null# is returned.

If the source is [.kw]#null#, the result is [.kw]#null#.

[[min]]
=== Min

*Signature:*

[source,cql]
----
Min(argument List<Integer>) Integer
Min(argument List<Decimal>) Decimal
Min(argument List<Quantity>) Quantity
Min(argument List<Date>) Date
Min(argument List<DateTime>) DateTime
Min(argument List<Time>) Time
Min(argument List<String>) String
----

*Description:*

The [.id]#Min# operator returns the minimum element in the source. Comparison semantics are defined by the <<Comparison Operators>> for the type of value being aggregated.

If the source contains no non-null elements, [.kw]#null# is returned.

If the source is [.kw]#null#, the result is [.kw]#null#.

[[median]]
=== Median

*Signature:*

[source,cql]
----
Median(argument List<Decimal>) Decimal
Median(argument List<Quantity>) Quantity
----

*Description:*

The [.id]#Median# operator returns the median of the elements in source.

If the source contains no non-null elements, [.kw]#null# is returned.

If the source is [.kw]#null#, the result is [.kw]#null#.

[[mode]]
=== Mode

*Signature:*

[source,cql]
----
Mode(argument List<T>) T
----

*Description:*

The [.id]#Mode# operator returns the statistical mode of the elements in source.

If the source contains no non-null elements, [.kw]#null# is returned.

If the source is [.kw]#null#, the result is [.kw]#null#.

[[population-stddev]]
=== Population StdDev

*Signature:*

[source,cql]
----
PopulationStdDev(argument List<Decimal>) Decimal
PopulationStdDev(argument List<Quantity>) Quantity
----

*Description:*

The [.id]#PopulationStdDev# operator returns the statistical standard deviation of the elements in source.

If the source contains no non-null elements, [.kw]#null# is returned.

If the source is [.kw]#null#, the result is [.kw]#null#.

[[population-variance]]
=== Population Variance

*Signature:*

[source,cql]
----
PopulationVariance(argument List<Decimal>) Decimal
PopulationVariance(argument List<Quantity>) Quantity
----

*Description:*

The [.id]#PopulationVariance# operator returns the statistical population variance of the elements in source.

If the source contains no non-null elements, [.kw]#null# is returned.

If the source is [.kw]#null#, the result is [.kw]#null#.

[[product]]
=== Product

*Signature:*

[source,cql]
----
Product(argument List<Integer>) Integer
Product(argument List<Decimal>) Decimal
Product(argument List<Quantity>) Quantity
----

*Description:*

The [.id]#Product# operator returns the geometric product of the elements in source.

If the source contains no non-null elements, [.kw]#null# is returned.

If the source is [.kw]#null#, the result is [.kw]#null#.

[[stddev]]
=== StdDev

*Signature:*

[source,cql]
----
StdDev(argument List<Decimal>) Decimal
StdDev(argument List<Quantity>) Quantity
----

*Description:*

The [.id]#StdDev# operator returns the statistical standard deviation of the elements in source.

If the source contains no non-null elements, [.kw]#null# is returned.

If the list is [.kw]#null#, the result is [.kw]#null#.

[[sum]]
=== Sum

*Signature:*

[source,cql]
----
Sum(argument List<Integer>) Integer
Sum(argument List<Decimal>) Decimal
Sum(argument List<Quantity>) Quantity
----

*Description:*

The [.id]#Sum# operator returns the sum of non-null elements in the source.

If the source contains no non-null elements, [.kw]#null# is returned.

If the list is [.kw]#null#, the result is [.kw]#null#.

[[variance]]
=== Variance

*Signature:*

[source,cql]
----
Variance(argument List<Decimal>) Decimal
Variance(argument List<Quantity>) Quantity
----

*Description:*

The [.id]#Variance# operator returns the statistical variance of the elements in source.

If the source contains no non-null elements, [.kw]#null# is returned.

If the source is [.kw]#null#, the result is [.kw]#null#.

[[clinical-operators-3]]
== Clinical Operators

[[age]]
=== Age

*Signature:*

[source,cql]
----
AgeInYears() Integer
AgeInMonths() Integer
AgeInWeeks() Integer
AgeInDays() Integer
AgeInHours() Integer
AgeInMinutes() Integer
AgeInSeconds() Integer
----

*Description:*

The [.id]#Age# operators calculate the age of the patient as of now in the precision named in the operator.

If the patient’s birthdate is [.kw]#null#, the result is [.kw]#null#.

The [.id]#Age# operators are defined in terms of a date/time duration calculation. This means that if the age of the patient is not specified to the level of precision corresponding to the operator being invoked, the result will be an _uncertainty_ over the range of possible values, potentially causing some comparisons to return [.kw]#null#.

Note that for [.id]#AgeInYears#, the [.id]#birthDate# is specified as a [.id]#Date#, not a [.id]#DateTime#.

[[ageat]]
=== AgeAt

*Signature:*

[source,cql]
----
AgeInYearsAt(asOf Date) Integer
AgeInMonthsAt(asOf DateTime) Integer
AgeInWeeksAt(asOf DateTime) Integer
AgeInDaysAt(asOf DateTime) Integer
AgeInHoursAt(asOf DateTime) Integer
AgeInMinutesAt(asOf DateTime) Integer
AgeInSecondsAt(asOf DateTime) Integer
----

*Description:*

The [.id]#AgeAt# operators calculate the age of the patient as of the given date in the precision named in the operator.

If the patient’s birthdate is [.kw]#null#, or the [.id]#asOf# argument is [.kw]#null#, the result is [.kw]#null#.

The [.id]#AgeAt# operators are defined in terms of a date/time duration calculation. This means that if the age of the patient or the given [.id]#asOf# value are not specified to the level of precision corresponding to the operator being invoked, the will be an _uncertainty_ over the range of possible values, potentially causing some comparisons to return [.kw]#null#.

[[calculateage]]
=== CalculateAge

*Signature:*

[source,cql]
----
CalculateAgeInYears(birthDate Date) Integer
CalculateAgeInMonths(birthDate DateTime) Integer
CalculateAgeInWeeks(birthDate DateTime) Integer
CalculateAgeInDays(birthDate DateTime) Integer
CalculateAgeInHours(birthDate DateTime) Integer
CalculateAgeInMinutes(birthDate DateTime) Integer
CalculateAgeInSeconds(birthDate DateTime) Integer
----

*Description:*

The [.id]#CalculateAge# operators calculate the age of a person born on the given birthdate as of now in the precision named in the operator.

If the birthdate is [.kw]#null#, the result is [.kw]#null#.

The [.id]#CalculateAge# operators are defined in terms of a date/time duration calculation. This means that if the given [.id]#birthDate# is not specified to the level of precision corresponding to the operator being invoked, the result will be an _uncertainty_ over the range of possible values, potentially causing some comparisons to return [.kw]#null#.

[[calculateageat]]
=== CalculateAgeAt

*Signature:*

[source,cql]
----
CalculateAgeInYearsAt(birthDate Date, asOf Date) Integer
CalculateAgeInMonthsAt(birthDate DateTime, asOf DateTime) Integer
CalculateAgeInWeeksAt(birthDate DateTime, asOf DateTime) Integer
CalculateAgeInDaysAt(birthDate DateTime, asOf DateTime) Integer
CalculateAgeInHoursAt(birthDate DateTime, asOf DateTime) Integer
CalculateAgeInMinutesAt(birthDate DateTime, asOf DateTime) Integer
CalculateAgeInSecondsAt(birthDate DateTime, asOf DateTime) Integer
----

*Description:*

The [.id]#CalculateAgeAt# operators calculate the age of a person born on the given birthdate as of the given date in the precision named in the operator.

If the [.id]#birthDate# is [.kw]#null# or the [.id]#asOf# argument is [.kw]#null#, the result is [.kw]#null#.

The [.id]#CalculateAgeAt# operators are defined in terms of a date/time duration calculation. This means that if the given [.id]#birthDate# or [.id]#asOf# are not specified to the level of precision corresponding to the operator being invoked, the result will be an _uncertainty_ over the range of possible values, potentially causing some comparisons to return [.kw]#null#.

[[equal-3]]
=== Equal

*Signature:*

[source,cql]
----
=(left Code, right Code) Boolean
=(left Concept, right Concept) Boolean
----

*Description:*

The _equal_ ([.sym]#=#) operator for Codes and Concepts uses tuple equality semantics. This means that the operator will return [.kw]#true# if and only if the values for each element by name are equal.

If either argument is [.kw]#null#, or contains any [.kw]#null# components, the result is [.kw]#null#.

[[equivalent-3]]
=== Equivalent

*Signature:*

[source,cql]
----
~(left Code, right Code) Boolean
~(left Concept, right Concept) Boolean
~(left Code, right Concept) Boolean
~(left Concept, right Code) Boolean
----

*Description:*

The [.sym]#~# operator for [.id]#Code# values returns [.kw]#true# if the [.id]#code# and [.id]#system# elements are equivalent. The [.id]#version# and [.id]#display# elements are ignored for the purposes of determining [.id]#Code# equivalence.

For [.id]#Concept# values, equivalence is defined as a non-empty intersection of the codes in each [.id]#Concept#. The [.id]#display# element is ignored for the purposes of determining [.id]#Concept# equivalence.

Note that this operator will always return [.kw]#true# or [.kw]#false#, even if either or both of its arguments are [.kw]#null#, or contain [.kw]#null# components.

Note carefully that this notion of _equivalence_ is _not_ the same as the notion of equivalence used in terminology: “these codes represent the same concept.” CQL specifically avoids defining terminological equivalence. The notion of equivalence defined here is used to provide consistent and intuitive semantics when dealing with missing information in membership contexts.

[[in-codesystem]]
=== In (Codesystem)

*Signature:*

[source,cql]
----
in(code String, codesystem CodeSystemRef) Boolean
in(code Code, codesystem CodeSystemRef) Boolean
in(concept Concept, codesystem CodeSystemRef) Boolean
in(codes List<Code>, codeSystem CodeSystemRef) Boolean
----

*Description:*

The [.kw]#in# (Codesystem) operators determine whether or not a given code, or any of a list of codes, is in a particular codesystem. Note that these operators can only be invoked by referencing a defined [.kw]#codesystem#.

For the [.id]#String# overload, if the given code system contains a code with an equivalent code element, the result is [.kw]#true#.

For the [.id]#Code# overload, if the given code system contains an equivalent code, the result is [.kw]#true#.

For the [.id]#Concept# overload, if the given code system contains a code equivalent to any code in the given concept, the result is [.kw]#true#.

For the [.id]#List<Code># overload, if the given code system contains a code equivalent to any code in the given list, the result is [.kw]#true#.

If the [.id]#code# argument is [.kw]#null#, the result is [.kw]#false#.

If the [.id]#code# system reference cannot be resolved, a run-time error is thrown.

[[in-valueset]]
=== In (Valueset)

*Signature:*

[source,cql]
----
in(code String, valueset ValueSetRef) Boolean
in(code Code, valueset ValueSetRef) Boolean
in(concept Concept, valueset ValueSetRef) Boolean
in(codes List<Code>, valueset ValueSetRef) Boolean
----

*Description:*

The [.kw]#in# (Valueset) operators determine whether or not a given code, or any of a list of codes, is in a particular valueset. Note that these operators can only be invoked by referencing a defined [.kw]#valueset#.

For the [.id]#String# overload, if the given valueset contains a code with an equivalent code element, the result is [.kw]#true#. Note that for this overload, because the code being tested cannot specify code system information, if the resolved value set contains codes from multiple code systems, a run-time error is thrown because the operation is ambiguous.

For the [.id]#Code# overload, if the given valueset contains an equivalent code, the result is [.kw]#true#.

For the [.id]#Concept# overload, if the given valueset contains a code equivalent to any code in the given concept, the result is [.kw]#true#.

For the [.id]#List<Code># overload, if the given valueset contains a code equivalent to any code in the given list, the result is [.kw]#true#.

If the code argument is [.kw]#null#, the result is [.kw]#false#.

If the value set reference cannot be resolved, a run-time error is thrown.

[[errors-and-messaging]]
== Errors and Messaging

[[message]]
=== Message

*Signature:*

[source,cql]
----
Message(source T, condition Boolean, code String, severity String, message String) T
----

*Description:*

The [.id]#Message# operator provides a run-time mechanism for returning messages, warnings, traces, and errors to the calling environment.

The source operator is any type and the result of the operation is the input source; the operation performs no modifications to input. This allows the message operation to appear at any point in any expression of CQL.

The condition is used to determine whether the message is generated and returned to the calling environment. If condition is true, the message is generated. Otherwise, the operation only returns the results and performs no processing at all.

The code provides a coded representation of the error. Note that this is a token (like a string or integer), not a terminology Code.

The severity determines what level of processing should occur for the message that is generated:

* Trace – The operation produces an informational message that is expected to be made available to a tracing mechanism such as a debug log in the calling environment. In addition, some representation of the contents of the source parameter should be made available to the tracing mechanism.
* Message – The operation produces an informational message that is expected to be made available in some way to the calling environment.
* Warning – The operation produces a warning message that is expected to be made conspicuously available to the calling environment, potentially to the end-user of the logic.
* Error – The operation produces a run-time error and return the message to the calling environment. This is the only severity that stops evaluation. All other severities continue evaluation of the expression.

If no severity is supplied, a default severity of Message is assumed.

The message is the content of the actual message that is sent to the calling environment.

Note that for Trace severity, the implementation should output the contents of the source parameter as part of the trace message. Because the logic may be operating on patient information, the utmost care should be taken to ensure that appropriate safeguards are in place to avoid logging sensitive information. At a minimum, all PHI should be redacted from these trace messages.

